
\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"

\usepackage{url}
\usepackage{algpseudocode}
\usepackage{algorithm}
\algrenewcommand{\algorithmiccomment}[1]{\State /*#1*/}
\algnewcommand\algorithmicto{$\textbf{to}$}
\algrenewtext{For}[3]{\algorithmicfor\ #1 $\gets$ #2 \algorithmicto\ #3 \algorithmicdo}
\newtheorem{hypothesis}[theorem]{Hypothesis}

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{P versus NP} %TODO Please add

\titlerunning{P vs NP}%optional, please use if title is longer than one line

\author{Frank Vega}{Joysonic, Uzun Mirkova 5, Belgrade, 11000, Serbia} {vega.frank@gmail.com}{https://orcid.org/0000-0001-8210-4126}{}


\authorrunning{F. Vega}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

%\Copyright{John Q. Public and Joan R. Public}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Complexity classes}
\ccsdesc[300]{Theory of computation~Problems, reductions and completeness}
%\ccsdesc[100]{Mathematics of computing~Number-theoretic computations}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{complexity classes, completeness, polynomial time, reduction, logarithmic space, one-way}%TODO mandatory; please add comma-separated list of keywords

%\category{}%optional, e.g. invited paper

%\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{https://www.academia.edu/39721020/Solution_of_the_P_versus_NP_Problem}.}

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

\nolinenumbers %uncomment to disable line numbering

\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\EventEditors{John Q. Open and Joan R. Access}
%\EventNoEds{2}
%\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
%\EventShortTitle{CVIT 2016}
%\EventAcronym{CVIT}
%\EventYear{2016}
%\EventDate{December 24--27, 2016}
%\EventLocation{Little Whinging, United Kingdom}
%\EventLogo{}
%\SeriesVolume{42}
%\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
P versus NP is considered as one of the most important open problems in computer science. This consists in knowing the answer of the following question: Is P equal to NP? It was essentially mentioned in 1955 from a letter written by John Nash to the United States National Security Agency. However, a precise statement of the P versus NP problem was introduced independently by Stephen Cook and Leonid Levin. Since that date, all efforts to find a proof for this problem have failed. Another major complexity classes are L and NL. Whether L = NL is another fundamental question that it is as important as it is unresolved. We show if L is equal to NL, then P = NP. In addition, we demonstrate that L is equal to NL. In this way, we prove the complexity class P is equal to NP. Furthermore, we demonstrate the complexity class L is equal to NP.
\end{abstract}

\section{Introduction}

In previous years there has been great interest in the verification or checking of computations \cite{LIP90}. Interactive proofs introduced by Goldwasser, Micali and Rackoff and Babi can be viewed as a model of the verification process \cite{LIP90}. Dwork and Stockmeyer and Condon have studied interactive proofs where the verifier is a space bounded computation instead of the original model where the verifier is a time bounded computation \cite{LIP90}. In addition, Blum and Kannan has studied another model where the goal is to check a computation based solely on the final answer \cite{LIP90}. More about probabilistic logarithmic space verifiers and the complexity class $NP$ has been investigated on a technique of Lipton \cite{LIP90}. In this work, we show some results about the logarithmic space verifiers applied to the class $NP$ and logarithmic space disqualifiers applied to the class $coNP$ which solve one of the most important open problems in computer science, that is $P$ versus $NP$.

The $P$ versus $NP$ problem is a major unsolved problem in computer science \cite{CS00}. This is considered by many to be the most important open problem in the field \cite{CS00}. It is one of the seven Millennium Prize Problems selected by the Clay Mathematics Institute to carry a US\$1,000,000 prize for the first correct solution \cite{CS00}. The precise statement of the $P=NP$ problem was introduced in 1971 by Stephen Cook in a seminal paper \cite{CS00}. In 2012, a poll of 151 researchers showed that 126 (83\%) believed the answer to be no, 12 (9\%) believed the answer is yes, 5 (3\%) believed the question may be independent of the currently accepted axioms and therefore impossible to prove or disprove, 8 (5\%) said either do not know or do not care or don't want the answer to be yes nor the problem to be resolved \cite{GA12}.

The $P = NP$ question is also singular in the number of approaches that researchers have brought to bear upon it over the years \cite{DEO10}. From the initial question in logic, the focus moved to complexity theory where early work used diagonalization and relativization techniques \cite{DEO10}. It was showed that these methods were perhaps inadequate to resolve $P$ versus $NP$ by demonstrating relativized worlds in which $P = NP$ and others in which $P \neq NP$ \cite{BA75}. This shifted the focus to methods using circuit complexity and for a while this approach was deemed the one most likely to resolve the question \cite{DEO10}. Once again, a negative result showed that a class of techniques known as $``$Natural Proofs$"$ that subsumed the above could not separate the classes $NP$ and $P$, provided one-way functions exist \cite{RAZ97}. There has been speculation that resolving the $P = NP$ question might be outside the domain of mathematical techniques \cite{DEO10}. More precisely, the question might be independent of standard axioms of set theory \cite{DEO10}. Some results have showed that some relativized versions of the $P = NP$ question are independent of reasonable formalizations of set theory \cite{HOP76}.

It is fully expected that $P \neq NP$ \cite{Pap03}. Indeed, if $P = NP$ then there are stunning practical consequences \cite{Pap03}. For that reason, $P = NP$ is considered as a very unlikely event \cite{Pap03}. Certainly, $P$ versus $NP$ is one of the greatest open problems in science and a correct solution for this incognita will have a great impact not only in computer science, but for many other fields as well \cite{AS17}. Whether $P = NP$ or not is still a controversial and unsolved problem \cite{AS17}. We show some results that prove this outstanding problem with the unexpected solution of $P = NP$.

\section{Theory and Methods}

\subsection{Preliminaries}

In 1936, Turing developed his theoretical computational model \cite{MS06}. The deterministic and nondeterministic Turing machines have become in two of the most important definitions related to this theoretical model for computation \cite{MS06}. A deterministic Turing machine has only one next action for each step defined in its program or transition function \cite{MS06}. A nondeterministic Turing machine could contain more than one action defined for each step of its program, where this one is no longer a function, but a relation \cite{MS06}.

Let $\Sigma$ be a finite alphabet with at least two elements, and let $\Sigma^{*}$ be the set of finite strings over $\Sigma$ \cite{AB09}. A Turing machine $M$ has an associated input alphabet $\Sigma$ \cite{AB09}. For each string $w$ in $\Sigma^{*}$ there is a computation associated with $M$ on input $w$ \cite{AB09}. We say that $M$ accepts $w$ if this computation terminates in the accepting state, that is $M(w)=``yes"$ \cite{AB09}. Note that $M$ fails to accept $w$ either if this computation ends in the rejecting state, that is $M(w)=``no"$, or if the computation fails to terminate, or the computation ends in the halting state with some output, that is $M(w)=y$ (when $M$ outputs the string $y$ on the input $w$) \cite{AB09}.

Another relevant advance in the last century has been the definition of a complexity class. A language over an alphabet is any set of strings made up of symbols from that alphabet \cite{CLRS01}. A complexity class is a set of problems, which are represented as a language, grouped by measures such as the running time, memory, etc \cite{CLRS01}. The language accepted by a Turing machine $M$, denoted $L(M)$, has an associated alphabet $\Sigma$ and is defined by:
\[L(M) = \{w \in \Sigma^{*}: M(w)=``yes" \}.\]
Moreover, $L(M)$ is decided by $M$, when $w \notin L(M)$ if and only if $M(w)=``no"$ \cite{CLRS01}. We denote by $t_{M}(w)$ the number of steps in the computation of $M$ on input $w$ \cite{AB09}. For $n \in \mathbb{N}$ we denote by $T_{M}(n)$ the worst case run time of $M$; that is:
\[T_{M}(n) = max\{t_{M}(w): w \in \Sigma^{n} \}\]
where $\Sigma^{n}$ is the set of all strings over $\Sigma$ of length $n$ \cite{AB09}. We say that $M$ runs in polynomial time if there is a constant $k$ such that for all $n$, $T_{M}(n) \leq n^{k} + k$ \cite{AB09}. In other words, this means the language $L(M)$ can be decided by the Turing machine $M$ in polynomial time. Therefore, $P$ is the complexity class of languages that can be decided by deterministic Turing machines in polynomial time \cite{CLRS01}. A verifier for a language $L_{1}$ is a deterministic Turing machine $M$, where:
\[L_{1} = \{w: M(w, c) = ``yes" \textit{ for some string } c\}.\]
We measure the time of a verifier only in terms of the length of $w$, so a polynomial time verifier runs in polynomial time in the length of $w$ \cite{AB09}. A verifier uses additional information, represented by the symbol $c$, to verify that a string $w$ is a member of $L_{1}$. This information is called certificate. $NP$ is the complexity class of languages defined by polynomial time verifiers \cite{Pap03}. If $NP$ is the class of problems that have succinct certificates, then the complexity class $coNP$ must contain those problems that have succinct disqualifications \cite{Pap03}. That is, a $``no"$ instance of a problem in $coNP$ possesses a short proof of its being a $``no"$ instance \cite{Pap03}.

\begin{definition}
We will extend the definition of succinct disqualification for an element $w \in L_{2}$ when $L_{2} \in coNP$ as the polynomially bounded string $c$ by $w$ such that $M(w, c) = ``no"$ and $M$ is the polynomial time verifier of the complement of $L_{2}$ in $NP$.
\end{definition}

\subsection{Hypothesis}

A function $f : \Sigma^{*} \rightarrow \Sigma^{*}$ is a polynomial time computable function if some deterministic Turing machine $M$, on every input $w$, halts in polynomial time with just $f(w)$ on its tape \cite{MS06}. Let $\{0, 1\}^{*}$ be the infinite set of binary strings, we say that a language $L_{1} \subseteq \{0, 1\}^{*}$ is polynomial time reducible to a language $L_{2} \subseteq \{0, 1\}^{*}$, written $L_{1} \leq_{p} L_{2}$, if there is a polynomial time computable function $f : \{0, 1\}^{*} \rightarrow \{0, 1\}^{*}$ such that for all $x \in \{0, 1\}^{*}$:
\[x \in L_{1} \textit{ if and only if } f(x) \in L_{2}.\]
An important complexity class is $\textit{NP--complete}$ \cite{GJ79}. A language $L_{1} \subseteq \{0, 1\}^{*}$ is $\textit{NP--complete}$ if:

\begin{itemize}
\item $L_{1} \in NP$, and
\item $L' \leq_{p} L_{1}$ for every $L' \in NP$.
\end{itemize}

If $L_{1}$ is a language such that $L' \leq_{p} L_{1}$ for some $L' \in \textit{NP--complete}$, then $L_{1}$ is $\textit{NP--hard}$ \cite{CLRS01}. Moreover, if $L_{1} \in NP$, then $L_{1} \in \textit{NP--complete}$ \cite{CLRS01}. A principal $\textit{NP--complete}$ problem is $SAT$ \cite{GJ79}. An instance of $SAT$ is a Boolean formula $\phi$ which is composed of:

\begin{enumerate}
\item Boolean variables: $x_{1}, x_{2},\ldots, x_{n}$;
\item Boolean connectives: Any Boolean function with one or two inputs and one output, such as $\wedge$(AND), $\vee$(OR), $\rightharpoondown$(NOT), $\Rightarrow$(implication), $\Leftrightarrow$(if and only if);
\item and parentheses.
\end{enumerate}

A truth assignment for a Boolean formula $\phi$ is a set of values for the variables in $\phi$. A satisfying truth assignment is a truth assignment that causes $\phi$ to be evaluated as true. A Boolean formula with a satisfying truth assignment is satisfiable. The problem $SAT$ asks whether a given Boolean formula is satisfiable \cite{GJ79}. We define a $CNF$ Boolean formula using the following terms:

A literal in a Boolean formula is an occurrence of a variable or its negation \cite{CLRS01}. A Boolean formula is in conjunctive normal form, or $CNF$, if it is expressed as an AND of clauses, each of which is the OR of one or more literals \cite{CLRS01}. A Boolean formula is in 3-conjunctive normal form or $3CNF$, if each clause has exactly three distinct literals \cite{CLRS01}.

For example, the Boolean formula:
\[(x_{1} \vee \rightharpoondown x_{1} \vee \rightharpoondown x_{2}) \wedge (x_{3} \vee x_{2} \vee x_{4}) \wedge (\rightharpoondown x_{1} \vee \rightharpoondown x_{3} \vee \rightharpoondown x_{4})\]
is in $3CNF$. The first of its three clauses is $(x_{1} \vee \rightharpoondown x_{1} \vee \rightharpoondown x_{2})$, which contains the three literals $x_{1}$, $\rightharpoondown x_{1}$, and $\rightharpoondown x_{2}$. Another relevant $\textit{NP--complete}$ language is $3CNF$ satisfiability, or $3SAT$ \cite{CLRS01}. In $3SAT$, it is asked whether a given Boolean formula $\phi$ in $3CNF$ is satisfiable.

A logarithmic space Turing machine has a read-only input tape, a write-only output tape, and read/write work tapes \cite{MS06}. The work tapes may contain at most $O(\log n)$ symbols \cite{MS06}. In computational complexity theory, $L$ is the complexity class containing those decision problems that can be decided by a deterministic logarithmic space Turing machine \cite{Pap03}. $NL$ is the complexity class containing the decision problems that can be decided by a nondeterministic logarithmic space Turing machine \cite{Pap03}.

A logarithmic space transducer is a Turing machine with a read-only input tape, a write-only output tape, and read/write work tapes \cite{MS06}. The work tapes must contain at most $O(\log n)$ symbols \cite{MS06}. A logarithmic space transducer $M$ computes a function $f : \Sigma^{*} \rightarrow \Sigma^{*}$, where $f(w)$ is the string remaining on the output tape after $M$ halts when it is started with $w$ on its input tape \cite{MS06}. We call $f$ a logarithmic space computable function \cite{MS06}. We say that a language $L_{1} \subseteq \{0, 1\}^{*}$ is logarithmic space reducible to a language $L_{2} \subseteq \{0, 1\}^{*}$, written $L_{1} \leq_{l} L_{2}$, if there exists a logarithmic space computable function $f : \{0, 1\}^{*} \rightarrow \{0, 1\}^{*}$ such that for all $x \in \{0, 1\}^{*}$:
\[x \in L_{1} \textit{ if and only if } f(x) \in L_{2}.\]
The logarithmic space reduction is used in the definition of the complete languages for the classes $L$ and $NL$ \cite{Pap03}. A Boolean formula is in 2-conjunctive normal form, or $2CNF$, if it is in $CNF$ and each clause has exactly two distinct literals. There is a problem called $2SAT$, where we asked whether a given Boolean formula $\phi$ in $2CNF$ is satisfiable. $2SAT$ is complete for $NL$ \cite{Pap03}. Another special case is the class of problems where each clause contains $XOR$ (i.e. exclusive or) rather than (plain) $OR$ operators. This is in $P$, since an $\textit{XOR SAT}$ formula can also be viewed as a system of linear equations mod $2$, and can be solved in cubic time by Gaussian elimination \cite{MM11}. We denote the $XOR$ function as $\oplus$. The $\textit{XOR 2SAT}$ problem will be equivalent to $\textit{XOR SAT}$, but the clauses in the formula have at most two distinct literals \cite{AR00}. $\textit{XOR 2SAT}$ is in $L$ \cite{AR00}, \cite{RM08}.

We can give a certificate-based definition for $NL$ \cite{AB09}. The certificate-based definition of $NL$ assumes that a logarithmic space Turing machine has another separated read-only tape \cite{AB09}. On each step of the machine, the machine's head on that tape can either stay in place or move to the right \cite{AB09}. In particular, it cannot reread any bit to the left of where the head currently is \cite{AB09}. For that reason this kind of special tape is called $``$read-once$"$ \cite{AB09}. Besides, in the certificate-based definition of $NL$, we assume the certificate string is appropriated for the instance \cite{Pap03}. For example, a truth assignment for a Boolean formula $\phi$ is appropriated for the instance when every possible variable in $\phi$ could be evaluated in that truth assignment string, but we cannot affirm the same for every possible binary string.

\begin{definition}
A language $L_{1}$ is in $NL$ if there exists a deterministic logarithmic space Turing machine $M$ with an additional special read-once input tape polynomial $p: \mathbb{N} \rightarrow \mathbb{N}$ such that for every $x \in \{0, 1\}^{*}$:
\[x \in L_{1} \Leftrightarrow \exists \textit{ appropriated } u \in \{0, 1\}^{p(|x|)} \textit{ such that } M(x, u) = ``yes" \]
where by $M(x, u)$ we denote the computation of $M$ where $x$ is placed on its input tape and the certificate $u$ is placed on its special read-once tape, and $M$ uses at most $O(\log |x|)$ space on its read/write tapes for every input $x$ where $|\ldots|$ is the bit-length function \cite{AB09}. $M$ is called a logarithmic space verifier \cite{AB09}.
\end{definition}

An important complexity class is $\textit{coNP--complete}$ \cite{GJ79}. A language $L_{1} \subseteq \{0, 1\}^{*}$ is $\textit{coNP--complete}$ if:

\begin{itemize}
\item $L_{1} \in coNP$, and
\item $L' \leq_{p} L_{1}$ for every $L' \in coNP$.
\end{itemize}

If $L_{1}$ is a language such that $L' \leq_{p} L_{1}$ for some $L' \in \textit{coNP--complete}$, then $L_{1}$ is $\textit{coNP--hard}$ \cite{CLRS01}. Moreover, if $L_{1} \in coNP$, then $L_{1} \in \textit{coNP--complete}$ \cite{CLRS01}. A principal $\textit{coNP--complete}$ problem is $UNSAT$ \cite{GJ79}. A Boolean formula without any satisfying truth assignment is unsatisfiable. The problem $UNSAT$ asks whether a given Boolean formula is unsatisfiable \cite{GJ79}.

$coNL$ is the complexity class containing the languages such that their complements belong to $NL$ \cite{Pap03}. We can give a disqualification-based definition for $coNL$ \cite{AB09}. The disqualification-based definition of $coNL$ assumes that a logarithmic space Turing machine has another separated read-only tape, that is the same kind of special tape called $``$read-once$"$ that we use in the certificate-based definition for $NL$ \cite{AB09}. Besides, in the disqualification-based definition of $coNL$, we assume the disqualification string is appropriated for the instance \cite{Pap03}.

\begin{definition}
A language $L_{1}$ is in $coNL$ if there exists a deterministic logarithmic space Turing machine $M$ with an additional special read-once input tape polynomial $p: \mathbb{N} \rightarrow \mathbb{N}$ such that for every $x \in \{0, 1\}^{*}$:
\[x \in L_{1} \Leftrightarrow \forall \textit{ appropriated } u \in \{0, 1\}^{p(|x|)} \textit{ then } M(x, u) = ``yes" \]
where by $M(x, u)$ we denote the computation of $M$ where $x$ is placed on its input tape and the disqualification $u$ is placed on its special read-once tape, and $M$ uses at most $O(\log |x|)$ space on its read/write tapes for every input $x$ where $|\ldots|$ is the bit-length function. $M$ is called a logarithmic space disqualifier.
\end{definition}

For example, there is a well-known $coNL$ problem that states: Given a directed graph $G = (V, E)$ and two nodes $s, t \in V$, is there no possible path from $s$ to $t$? In that problem, an appropriated disqualification $u$ is a sequence of nodes contained in $V$ when $s$ is the first node and $t$ is the last one such that this sequence of nodes is not a path: There is at least a consecutive pair of nodes in the sequence where they are not connected by an edge.

From the early days of automata and complexity theory,  two  different  models  of  Turing  machines  are  considered, the offline and online machines \cite{KU15}. Each model has a read-only input tape and some work tapes \cite{KU15}. The offline machines may read their input two-way while the online machines are not allowed to move the input head to the left \cite{KU15}. In the terminology of the (generalized) Turing machine models are called two-way and one-way Turing machines, respectively \cite{KU15}.

Hartmanis and Mahaney have investigated the classes $1L$ and $1NL$ of languages recognizable by deterministic one-way logarithmic space Turing machine and nondeterministic one-way logarithmic space Turing machine, respectively \cite{HM81}. They have shown that $1L \neq 1NL$ (by looking at a uniform variant of the string non-equality problem from communication complexity theory) and have defined a natural complete problem for $1NL$ under deterministic one-way logarithmic space reductions \cite{HM81}. Furthermore, they have proven that $1NL \subseteq L$ if and only if $L=NL$ \cite{HM81}.

We state the following Hypothesis:

\begin{hypothesis}
\label{hypothesis2}
Given a nonempty language $L_{1} \in 1NL$, there is a language $L_{2}$ in $\textit{coNP--complete}$ with a deterministic Turing machine $M$, where:
\[L_{2} = \{w: M(w, u) = y, \forall \textit{ appropriated } u \textit{ such that } y \in L_{1}\}\]
when $M$ runs in logarithmic space in the length of $w$, $u$ is placed on the special read-once tape of $M$, and $u$ is polynomially bounded by $w$. In this way, there is a $\textit{coNP--complete}$ language defined by a logarithmic space disqualifier $M$ such that when the input is an element of the language with any of its appropriated disqualification, then $M$ always outputs a string which belongs to a single language in $1NL$.
\end{hypothesis}

\begin{theorem}
\label{pos-implication}
If the Hypothesis \ref{hypothesis2} is true, therefore when $L = NL$, then $P = NP$.
\end{theorem}

\begin{proof}
We can accept the elements of the language $L_{1} \in 1NL$ by a nondeterministic one-way logarithmic space Turing machine $M'$. In this way, there is a nondeterministic logarithmic space Turing machine $M''(w, u) = M'(M(w, u))$ which will accept when $w \in L_{2}$ for all the appropriated disqualification $u$, where $u$ is placed on the special read-once tape of $M''$. The reason is because we can simulate the output string of $M(w, u)$ within a read-once tape and thus, we can compute in a nondeterministic logarithmic space the logarithmic space composition using the same techniques of the logarithmic space composition reduction, but without any reset of the computation \cite{Pap03}. Certainly, we do not need to reset the computation of $M(w, u)$ for the reading at once of a symbol in the output string of $M(w, u)$ by the nondeterministic one-way logarithmic space Turing machine $M'$. Consequently, $M''$ can be converted into a logarithmic space disqualifier for the language $L_{2}$ just assuming that $L = NL$, because of the nondeterministic logarithmic space Turing machine $M''$ could be simulated by a deterministic logarithmic space Turing machine. Therefore, $L_{2}$ is in $coNL$ and thus, $L_{2} \in P$ due to $coNL \subseteq P$ \cite{Pap03}. If any single $\textit{coNP--complete}$ problem can be solved in polynomial time, then $P = NP$ \cite{Pap03}. Since $L_{2} \in P$ and $L_{2} \in \textit{coNP--complete}$, then we obtain the complexity class $P$ is equal to $NP$ under the assumption that $L = NL$.
\end{proof}

\section{Results}

\subsection{Hypothesis}

We show a previous known $\textit{coNP--complete}$ problem:

\begin{definition}
$\textbf{3UNSAT}$

INSTANCE: A Boolean formula $\phi$ in $3CNF$.

QUESTION: Is $\phi$ unsatisfiable?

REMARKS: $3UNSAT \in \textit{coNP--complete}$ \cite{GJ79}.
\end{definition}

We define a new problem:

\begin{definition}
$\textbf{SUM ZERO}$

INSTANCE: A collection of integers $C$ such that $0 \notin C$ and every integer in $C$ has the same bit-length of the number that represents the cardinality of $C$ multiplied by $3$ (we do not take into account the symbol minus in counting the bit-length of the negative integers).

QUESTION: Are there two elements $a, b \in C$, such that $a + b = 0$?

REMARKS: We denote this problem as $\textit{SUM--ZERO}$.
\end{definition}


\begin{theorem}
\label{1nl}
$\textit{SUM--ZERO} \in 1NL$.
\end{theorem}

\begin{proof}
Given a collection of integers $C$, we can read its elements from left to right, verify that every element is not equal to $0$, check that every element in $C$ has the same bit-length and count the amount of elements in $C$ to finally multiply it by $3$ and compare its bit-length with the single bit-length from the elements in $C$. In addition, we can nondeterministically pick two elements $a$ and $b$ from $C$ and accept in case of $a + b = 0$ otherwise we reject. We can make all this computation in a nondeterministic one-way using logarithmic space. Certainly, the calculation and store of the bit-length of the elements in $C$ could be done in logarithmic space since this is a unique value. On the one hand, we can count and store the number of elements that we read from the input and multiply it by $3$ to finally compare its bit-length with the stored unique bit-length from the elements of the collection, since the cardinality of $C$ multiplied by $3$ could be stored in a binary number of bit-length that is logarithmic in relation to the encoded length of $C$. On the other hand, the two elements $a$ and $b$ that we pick from $C$ have a logarithmic space in relation to the encoded length of $C$, because of every integer in $C$ has the same bit-length of the number that represents the cardinality of $C$ multiplied by $3$. Indeed, we never need to read to the left on the input for the acceptance of the elements in $\textit{SUM--ZERO}$ in a nondeterministic logarithmic space.
\end{proof}

\begin{theorem}
\label{demonstration}
There is a deterministic Turing machine $M$, where:
\[3UNSAT = \{w: M(w, u) = y, \forall \textit{ appropriated } u \textit{ such that } y \in \textit{SUM--ZERO}\}\]
when $M$ runs in logarithmic space in the length of $w$, $u$ is placed on the special read-once tape of $M$, and $u$ is polynomially bounded by $w$.
\end{theorem}

\begin{proof}
Given a Boolean formula $\phi$ in $3CNF$ with $n$ variables and $m$ clauses, we can create a disqualification array $A$ which contains $m$ positive integers between $1$ and $3$ which represents the literals of the clauses in $\phi$ which appear from left to right. We read at once the elements of the array $A$ and we reject whether this is not an appropriated disqualification: That is when the array $A$ does not contain exactly $m$ elements, or the array $A$ contains a number that is not between $1$ and $3$. While we read the elements of the array $A$, we select from the clauses $\phi$ the literals such that these ones occupy the position that represents the number between $1$ and $3$, that is the first, second or third place within the clause from left to right. In this way, we output the selected literals that are represented by a positive or negative (in case of a negated variable) integer just creating another instance $C$ for $\textit{SUM--ZERO}$ where the collection $C$ contains those integers which are the selected literals for each clause in $\phi$. Therefore, we obtain that all the appropriated array $A$ would be valid according to the Theorem \ref{demonstration} when:
\[\phi \in 3UNSAT \Leftrightarrow (\forall \textit{ appropriated array } A \textit{ such that } C \in \textit{SUM--ZERO})\]
since we assume the positive and negated literals of some variable in the input $\phi$ correspond to a positive integer and its negative value, respectively. Furthermore, we can make this disqualification in logarithmic space such that the array $A$ is placed on the special read-once tape, because we read at once the elements in the array $A$. Hence, we only need to iterate from the elements of the array $A$ to verify whether the array is an appropriated disqualification and pick the $m$ literals from the Boolean formula $\phi$ when we write the final integers that represent these literals to the output. This logarithmic space disqualification will be the Algorithm \ref{algorithm2}. We assume whether a value does not exist in the array $A$ into the cell of some position $i$ when $A[i] = \textit{undefined}$. In addition, we reject immediately when the following comparisons:
\[A[i] < 1 \vee A[i] > 3\]
hold at least into one single binary digit. Note, that every possible literal in $\phi$ could have a representation by an integer between $-3 \times m$ and $3 \times m$ with the exception of $0$, where $m$ is the cardinality of the collection $C$. In this way, we guarantee the output collection $C$ is an appropriated instance of $\textit{SUM--ZERO}$ just filling with zeroes to the left the elements with bit-length lesser than $|3 \times m|$ where $|\ldots|$ is the bit-length function.

\begin{algorithm}
\caption{Logarithmic space disqualifier}\label{algorithm2}
\begin{algorithmic}[1]
\Comment{A valid instance for $3UNSAT$ with its disqualification}
\Procedure{$\textit{DISQUALIFIER}$}{$\phi, A$}
\Comment{Initialize an index}
\State $j \gets 0$
\Comment{$m$ is the number of clauses in $\phi$}
\Comment{Iterate for the elements of the disqualification array $A$}
\For{$i$}{$1$}{$m + 1$}
\If{$i = m+1$}
\Comment{There exists an $m+1$ element in the array}
\If{$A[i] \neq \textit{undefined}$}
\Comment{Reject the disqualification}
\State \textbf{return} $``no"$
\EndIf
\Comment{Break the $\textbf{for}$ loop}
\State \textbf{break}
\ElsIf{$A[i] = \textit{undefined} \vee A[i] < 1 \vee A[i] > 3$}
\Comment{Reject the disqualification}
\State \textbf{return} $``no"$
\Else
\State $j \gets A[i]$
\EndIf
\Comment{From the indexed $i^{th}$ clause $c_{i} = (x_{j} \vee y_{k} \vee z_{r})$ in $\phi$}
\Comment{Where $x$, $y$ and $z$ are literals with local indexes $\{j, k, r\} = \{1,2,3\}$ in $c_{i}$}
\Comment{Output the integer representation of the $j^{th}$ literal, that is $n(x_{j})$}
\Comment{Filled with zeroes to the left until a total of $|3 \times m|$ bits including the literal}
\Comment{But, the bit-length of the symbol minus is ignored in filling the negated literals}
\State \textbf{output} $``\ , \ n(x_{j})"$
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
\end{proof}

\begin{theorem}
\label{result2}
The Hypothesis \ref{hypothesis2} is true.
\end{theorem}

\begin{proof}
This is a consequence of Theorems \ref{1nl} and \ref{demonstration}.
\end{proof}

\begin{theorem}
\label{equal-NP}
If $L = NL$ then $P = NP$.
\end{theorem}

\begin{proof}
This is a direct consequence of Theorems \ref{pos-implication} and \ref{result2}.
\end{proof}

\subsection{L versus NL}

A directed graph $G = (V, E)$ is topologically sorted when for any pair of edges $(a, b)$ and $(b, c)$ in $G$, then the edge $(a, b)$ is listed before $(b, c)$ \cite{HM81}.

We show a previous known $\textit{NL--complete}$ problem:

\begin{definition}
$\textbf{TAGAP}$

INSTANCE: Given a directed graph $G = (V, E)$ that is topologically sorted and two nodes $s, t \in V$.

QUESTION: Is there a path from $s$ to $t$?

REMARKS: $TAGAP \in \textit{NL--complete}$ \cite{HM81}. Certainly, this problem remains in $\textit{NL--complete}$ even if the graph is not acyclic \cite{HM81}.
\end{definition}

\begin{definition}
An instance $\phi$ of $\textit{XOR 2SAT}$ is topologically sorted when for any pair of clauses $(a \oplus b)$ and $(b \oplus c)$ in $\phi$, then the clause $(a \oplus b)$ is listed before $(b \oplus c)$.
\end{definition}

\begin{definition}
$\textbf{TAGAP 2SAT}$

INSTANCE: Given an instance $\phi$ of $\textit{XOR 2SAT}$ that is topologically sorted.

QUESTION: Is there a truth assignment, such that each clause of one literal is satisfied and each clause of two literals has not a true and false evaluated literals at the same time?
\end{definition}

\begin{theorem}
$\textit{TAGAP 2SAT} \in L$.
\end{theorem}

\begin{proof}
We can check whether an instance $\phi$ of $\textit{XOR 2SAT}$ is topologically sorted in logarithmic space. Certainly, for each clause $(a \oplus b)$ we can verify in logarithmic space whether there is not another clause $(b \oplus c)$ that is listed before of $(a \oplus b)$. In addition, given an instance $\phi$ of $\textit{XOR 2SAT}$ with $m$ clauses, for each clause of two literals $c_{i} = (x \oplus y)$ in the input tape, we create a new clause $d_{i} = (x \oplus \rightharpoondown y)$ into the output tape, where $x$ and $y$ are literals. Moreover, for each clause of one literal $c_{i} = (x)$ in the input tape, we create the same clause $d_{i} = (x)$ into the output tape, where $x$ is a literal. Hence, we can create a new instance $\psi$ of $\textit{XOR 2SAT}$ as the conjunction of the $d_{i}$ clauses for every clause $c_{i}$ in $\phi$, such that $\psi = d_{1} \wedge \ldots \wedge d_{m}$. Finally, we obtain that:
\[\phi \in \textit{TAGAP 2SAT} \textit{ if and only if } \psi \in \textit{XOR 2SAT}.\]
Consequently, we prove $\textit{TAGAP 2SAT} \leq_{l} \textit{XOR 2SAT}$ where we already know the language $\textit{XOR 2SAT} \in L$ \cite{AR00}, \cite{RM08}. Since $L$ is closed under logarithmic space reductions, then we obtain that $\textit{TAGAP 2SAT} \in L$ \cite{Pap03}.
\end{proof}

\begin{lemma}
\label{nl-complete}
We have the complement of $TAGAP$ complies with $coTAGAP \in \textit{NL--complete}$.
\end{lemma}

\begin{proof}
This is trivially true since $NL$ is closed under complement \cite{Pap03}.
\end{proof}

\begin{theorem}
\label{reduction}
$coTAGAP \leq_{l} \textit{TAGAP 2SAT}$.
\end{theorem}

\begin{proof}
Given a directed graph $G = (V, E)$ that is topologically sorted and two nodes $s, t \in V$, for each edge $(x, y)$ in the input tape from left to right, we create a new clause $(x \oplus y)$ for an instance $\phi$ of $\textit{XOR 2SAT}$ into the output tape, where $x$ and $y$ are positive literals represented by the positive integers $x$ and $y$ which are two nodes in $G$. In addition, before we generate the first clause from the edges, then we create the clause $(\rightharpoondown s)$ into the output tape, and after we generate all the clauses, then we create the clause $(t)$ into the output tape from the IN and OUT nodes of the possible path $s, t \in V$: This is possible because an instance of $\textit{XOR 2SAT}$ have clauses of at most two literals \cite{AR00}.
We can see the final instance $\phi$ of $\textit{XOR 2SAT}$ into the output tape will be topologically sorted, since we create the clauses through the edges from left to right with the exception of $(\rightharpoondown s)$ that is the first clause and $(t)$ that is the last one in $\phi$. Hence, if $\phi$ is an acceptance instance of $\textit{TAGAP 2SAT}$, then there is no a possible path from $s$ to $t$ in $G$, because it is necessary that $s$ and $t$ must be false and true on the clauses $(\rightharpoondown s)$ and $(t)$, respectively. Certainly, if there is path from $s$ to $t$, then $s$ and $t$ should be both true or both false in order the instance $\phi$ of $\textit{TAGAP 2SAT}$ could be possible accepted. Finally, we obtain that:
\[G \in coTAGAP \textit{ if and only if } \phi \in \textit{TAGAP 2SAT}.\]
Consequently, we prove $coTAGAP \leq_{l} \textit{TAGAP 2SAT}$ \cite{Pap03}.
\end{proof}

\begin{theorem}
\label{equal-L}
$L = NL$.
\end{theorem}

\begin{proof}
A single language in $\textit{NL--complete}$ that is logarithmic space reduced to another language $L$, it is sufficiently to prove $L = NL$, since $L$ and $NL$ are closed under logarithmic space reduction \cite{Pap03}. Therefore, this is direct result from Lemma \ref{nl-complete} and Theorem \ref{reduction}.
\end{proof}

\begin{theorem}
$P = NP$.
\end{theorem}

\begin{proof}
This is a direct consequence of Theorems \ref{equal-NP} and \ref{equal-L}.
\end{proof}

\begin{theorem}
$L = NP$.
\end{theorem}

\begin{proof}
The $\textit{coNP--complete}$ problem in Theorem \ref{pos-implication}, that would be $3UNSAT$, is necessarily in $coNL$ and thus all the problems in $coNP$ when $L = NL$, because of every problem in $coNP$ can be actually logarithmic space reduced to $3UNSAT$ \cite{GJ79}. Certainly, every $coNP$ problem could be logarithmic space reduced to $UNSAT$ by the Cook's Theorem algorithm and $UNSAT$ can be indeed logarithmic space reduced to $3UNSAT$ \cite{GJ79}. Since we have that $L = NL = coNL$ is true, then the complexity class $L$ is equal to $NP$.
\end{proof}

\section{Conclusions}

No one has been able to find a polynomial time algorithm for any of more than $300$ important known $\textit{NP--complete}$ problems \cite{GJ79}. A proof of $P = NP$ will have stunning practical consequences, because it leads to efficient methods for solving some of the important problems in $NP$ \cite{CS00}. The consequences, both positive and negative, arise since various $\textit{NP--complete}$ problems are fundamental in many fields \cite{CS00}. The following consequences are assuming that we have a practical solution for the $\textit{NP--complete}$ problems where such existence was proven with our nonconstructive result:

Cryptography, for example, relies on certain problems being difficult. A constructive and efficient solution to an $\textit{NP--complete}$ problem such as $3SAT$ will break most existing cryptosystems including: Public-key cryptography \cite{HW97}, symmetric ciphers \cite{MM00} and one-way functions used in cryptographic hashing \cite{DKV07}. These would need to be modified or replaced by information-theoretically secure solutions not inherently based on $\textit{P--NP}$ equivalence.

There are enormous positive consequences that will follow from rendering tractable many currently mathematically intractable problems. For instance, many problems in operations research are $\textit{NP--complete}$, such as some types of integer programming and the traveling salesman problem \cite{GJ79}. Efficient solutions to these problems have enormous implications for logistics \cite{CS00}. Many other important problems, such as some problems in protein structure prediction, are also $\textit{NP--complete}$, so this will spur considerable advances in biology \cite{BL98}.

Since all the $\textit{NP--complete}$ optimization problems become easy, everything will be much more efficient \cite{LF09}. Transportation of all forms will be scheduled optimally to move people and goods around quicker and cheaper \cite{LF09}. Manufacturers can improve their production to increase speed and create less waste \cite{LF09}. Learning becomes easy by using the principle of Occam's razor: We simply find the smallest program consistent with the data \cite{LF09}. Near perfect vision recognition, language comprehension and translation and all other learning tasks become trivial \cite{LF09}. We will also have much better predictions of weather and earthquakes and other natural phenomenon \cite{LF09}.

There would be disruption, including maybe displacing programmers \cite{IMP95}. The practice of programming itself would be more about gathering training data and less about writing code \cite{IMP95}. Google would have the resources to excel in such a world \cite{IMP95}.

But such changes may pale in significance compared to the revolution an efficient method for solving $\textit{NP--complete}$ problems will cause in mathematics itself \cite{CS00}. Research mathematicians spend their careers trying to prove theorems, and some proofs have taken decades or even centuries to find after problems have been stated \cite{AS17}. For instance, Fermat's Last Theorem took over three centuries to prove \cite{AS17}. A method that is guaranteed to find proofs to theorems, should one exist of a $``$reasonable$"$ size, would essentially end this struggle \cite{CS00}.

\bibliography{manuscript}


\end{document}
