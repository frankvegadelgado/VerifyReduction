
\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"

\usepackage{url}
\usepackage{algpseudocode}
\usepackage{algorithm}
\algrenewcommand{\algorithmiccomment}[1]{\State /*#1*/}
\algnewcommand\algorithmicto{$\textbf{to}$}
\algrenewtext{For}[3]{\algorithmicfor\ #1 $\gets$ #2 \algorithmicto\ #3 \algorithmicdo}
\newtheorem{hypothesis}[theorem]{Hypothesis}

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{P versus NP} %TODO Please add

%\titlerunning{P vs NP}%optional, please use if title is longer than one line

\author{Frank Vega}{Joysonic, Uzun Mirkova 5, Belgrade, 11000, Serbia} {vega.frank@gmail.com}{https://orcid.org/0000-0001-8210-4126}{}


\authorrunning{F. Vega}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

%\Copyright{John Q. Public and Joan R. Public}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Complexity classes}
\ccsdesc[300]{Theory of computation~Problems, reductions and completeness}
%\ccsdesc[100]{Mathematics of computing~Number-theoretic computations}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{complexity classes, completeness, polynomial time, reduction, logarithmic space}%TODO mandatory; please add comma-separated list of keywords

%\category{}%optional, e.g. invited paper

%\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{https://www.academia.edu/39721020/Solution_of_the_P_versus_NP_Problem}.}

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

\nolinenumbers %uncomment to disable line numbering

\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\EventEditors{John Q. Open and Joan R. Access}
%\EventNoEds{2}
%\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
%\EventShortTitle{CVIT 2016}
%\EventAcronym{CVIT}
%\EventYear{2016}
%\EventDate{December 24--27, 2016}
%\EventLocation{Little Whinging, United Kingdom}
%\EventLogo{}
%\SeriesVolume{42}
%\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
P versus NP is considered as one of the most important open problems in computer science. This consists in knowing the answer of the following question: Is P equal to NP? It was essentially mentioned in 1955 from a letter written by John Nash to the United States National Security Agency. However, a precise statement of the P versus NP problem was introduced independently by Stephen Cook and Leonid Levin. Since that date, all efforts to find a proof for this problem have failed. Another major complexity classes are L and NL. Whether L = NL is another fundamental question that it is as important as it is unresolved. We demonstrate if L is not equal to NL, then P = NP. In addition, we show if L is equal to NL, then P = NP. In this way, we prove the complexity class P is equal to NP. Furthermore, we demonstrate the complexity class NL is equal to NP.
\end{abstract}

\section{Introduction}

In previous years there has been great interest in the verification or checking of computations \cite{LIP90}. Interactive proofs introduced by Goldwasser, Micali and Rackoff and Babi can be viewed as a model of the verification process \cite{LIP90}. Dwork and Stockmeyer and Condon have studied interactive proofs where the verifier is a space bounded computation instead of the original model where the verifier is a time bounded computation \cite{LIP90}. In addition, Blum and Kannan has studied another model where the goal is to check a computation based solely on the final answer \cite{LIP90}. More about probabilistic logarithmic space verifiers and the complexity class $NP$ has been investigated on a technique of Lipton \cite{LIP90}. In this work, we show some results about the logarithmic space verifiers applied to the class $NP$ and logarithmic space disqualifiers applied to the class $coNP$ which solve one of the most important open problems in computer science, that is $P$ versus $NP$.

The $P$ versus $NP$ problem is a major unsolved problem in computer science \cite{CS00}. This is considered by many to be the most important open problem in the field \cite{CS00}. It is one of the seven Millennium Prize Problems selected by the Clay Mathematics Institute to carry a US\$1,000,000 prize for the first correct solution \cite{CS00}. The precise statement of the $P=NP$ problem was introduced in 1971 by Stephen Cook in a seminal paper \cite{CS00}. In 2012, a poll of 151 researchers showed that 126 (83\%) believed the answer to be no, 12 (9\%) believed the answer is yes, 5 (3\%) believed the question may be independent of the currently accepted axioms and therefore impossible to prove or disprove, 8 (5\%) said either do not know or do not care or don't want the answer to be yes nor the problem to be resolved \cite{GA12}.

The $P = NP$ question is also singular in the number of approaches that researchers have brought to bear upon it over the years \cite{DEO10}. From the initial question in logic, the focus moved to complexity theory where early work used diagonalization and relativization techniques \cite{DEO10}. It was showed that these methods were perhaps inadequate to resolve $P$ versus $NP$ by demonstrating relativized worlds in which $P = NP$ and others in which $P \neq NP$ \cite{BA75}. This shifted the focus to methods using circuit complexity and for a while this approach was deemed the one most likely to resolve the question \cite{DEO10}. Once again, a negative result showed that a class of techniques known as $``$Natural Proofs$"$ that subsumed the above could not separate the classes $NP$ and $P$, provided one-way functions exist \cite{RAZ97}. There has been speculation that resolving the $P = NP$ question might be outside the domain of mathematical techniques \cite{DEO10}. More precisely, the question might be independent of standard axioms of set theory \cite{DEO10}. Some results have showed that some relativized versions of the $P = NP$ question are independent of reasonable formalizations of set theory \cite{HOP76}.

It is fully expected that $P \neq NP$ \cite{Pap03}. Indeed, if $P = NP$ then there are stunning practical consequences \cite{Pap03}. For that reason, $P = NP$ is considered as a very unlikely event \cite{Pap03}. Certainly, $P$ versus $NP$ is one of the greatest open problems in science and a correct solution for this incognita will have a great impact not only in computer science, but for many other fields as well \cite{AS17}. Whether $P = NP$ or not is still a controversial and unsolved problem \cite{AS17}. We show some results that prove this outstanding problem with the unexpected solution of $P = NP$.

\section{Theory and Methods}

\subsection{Preliminaries}

In 1936, Turing developed his theoretical computational model \cite{MS06}. The deterministic and nondeterministic Turing machines have become in two of the most important definitions related to this theoretical model for computation \cite{MS06}. A deterministic Turing machine has only one next action for each step defined in its program or transition function \cite{MS06}. A nondeterministic Turing machine could contain more than one action defined for each step of its program, where this one is no longer a function, but a relation \cite{MS06}.

Let $\Sigma$ be a finite alphabet with at least two elements, and let $\Sigma^{*}$ be the set of finite strings over $\Sigma$ \cite{AB09}. A Turing machine $M$ has an associated input alphabet $\Sigma$ \cite{AB09}. For each string $w$ in $\Sigma^{*}$ there is a computation associated with $M$ on input $w$ \cite{AB09}. We say that $M$ accepts $w$ if this computation terminates in the accepting state, that is $M(w)=1$ \cite{AB09}. Note that $M$ fails to accept $w$ either if this computation ends in the rejecting state, that is $M(w)=0$, or if the computation fails to terminate, or the computation ends in the halting state with some output, that is $M(w)=y$ (when $M$ outputs the string $y$ on the input $w$) \cite{AB09}.

Another relevant advance in the last century has been the definition of a complexity class. A language over an alphabet is any set of strings made up of symbols from that alphabet \cite{CLRS01}. A complexity class is a set of problems, which are represented as a language, grouped by measures such as the running time, memory, etc \cite{CLRS01}. The language accepted by a Turing machine $M$, denoted $L(M)$, has an associated alphabet $\Sigma$ and is defined by:
\[L(M) = \{w \in \Sigma^{*}: M(w)=1 \}.\]
Moreover, $L(M)$ is decided by $M$, when $w \notin L(M)$ if and only if $M(w)=0$ \cite{CLRS01}. We denote by $t_{M}(w)$ the number of steps in the computation of $M$ on input $w$ \cite{AB09}. For $n \in \mathbb{N}$ we denote by $T_{M}(n)$ the worst case run time of $M$; that is:
\[T_{M}(n) = max\{t_{M}(w): w \in \Sigma^{n} \}\]
where $\Sigma^{n}$ is the set of all strings over $\Sigma$ of length $n$ \cite{AB09}. We say that $M$ runs in polynomial time if there is a constant $k$ such that for all $n$, $T_{M}(n) \leq n^{k} + k$ \cite{AB09}. In other words, this means the language $L(M)$ can be decided by the Turing machine $M$ in polynomial time. Therefore, $P$ is the complexity class of languages that can be decided by deterministic Turing machines in polynomial time \cite{CLRS01}. A verifier for a language $L_{1}$ is a deterministic Turing machine $M$, where:
\[L_{1} = \{w: M(w, c) = 1 \textit{ for some string } c\}.\]
We measure the time of a verifier only in terms of the length of $w$, so a polynomial time verifier runs in polynomial time in the length of $w$ \cite{AB09}. A verifier uses additional information, represented by the symbol $c$, to verify that a string $w$ is a member of $L_{1}$. This information is called certificate. $NP$ is the complexity class of languages defined by polynomial time verifiers \cite{Pap03}. If $NP$ is the class of problems that have succinct certificates, then the complexity class $coNP$ must contain those problems that have succinct disqualifications \cite{Pap03}. That is, a rejection instance of a problem in $coNP$ possesses a short proof of its being a rejection instance \cite{Pap03}.

\begin{definition}
We will extend the definition of succinct disqualification for an element $w \in L_{2}$ when $L_{2} \in coNP$ as the polynomially bounded string $c$ by $w$ such that $M(w, c) = 0$ and $M$ is the polynomial time verifier of the complement of $L_{2}$ in $NP$.
\end{definition}

\subsection{Hypothesis}

A function $f : \Sigma^{*} \rightarrow \Sigma^{*}$ is a polynomial time computable function if some deterministic Turing machine $M$, on every input $w$, halts in polynomial time with just $f(w)$ on its tape \cite{MS06}. Let $\{0, 1\}^{*}$ be the infinite set of binary strings, we say that a language $L_{1} \subseteq \{0, 1\}^{*}$ is polynomial time reducible to a language $L_{2} \subseteq \{0, 1\}^{*}$, written $L_{1} \leq_{p} L_{2}$, if there is a polynomial time computable function $f : \{0, 1\}^{*} \rightarrow \{0, 1\}^{*}$ such that for all $x \in \{0, 1\}^{*}$:
\[x \in L_{1} \textit{ if and only if } f(x) \in L_{2}.\]
An important complexity class is $\textit{NP--complete}$ \cite{GJ79}. A language $L_{1} \subseteq \{0, 1\}^{*}$ is $\textit{NP--complete}$ if:

\begin{itemize}
\item $L_{1} \in NP$, and
\item $L' \leq_{p} L_{1}$ for every $L' \in NP$.
\end{itemize}

If $L_{1}$ is a language such that $L' \leq_{p} L_{1}$ for some $L' \in \textit{NP--complete}$, then $L_{1}$ is $\textit{NP--hard}$ \cite{CLRS01}. Moreover, if $L_{1} \in NP$, then $L_{1} \in \textit{NP--complete}$ \cite{CLRS01}. A principal $\textit{NP--complete}$ problem is $SAT$ \cite{GJ79}. An instance of $SAT$ is a Boolean formula $\phi$ which is composed of:

\begin{enumerate}
\item Boolean variables: $x_{1}, x_{2},\ldots, x_{n}$;
\item Boolean connectives: Any Boolean function with one or two inputs and one output, such as $\wedge$(AND), $\vee$(OR), $\rightharpoondown$(NOT), $\Rightarrow$(implication), $\Leftrightarrow$(if and only if);
\item and parentheses.
\end{enumerate}

A truth assignment for a Boolean formula $\phi$ is a set of values for the variables in $\phi$. A satisfying truth assignment is a truth assignment that causes $\phi$ to be evaluated as true. A Boolean formula with a satisfying truth assignment is satisfiable. The problem $SAT$ asks whether a given Boolean formula is satisfiable \cite{GJ79}. We define a $CNF$ Boolean formula using the following terms:

A literal in a Boolean formula is an occurrence of a variable or its negation \cite{CLRS01}. A Boolean formula is in conjunctive normal form, or $CNF$, if it is expressed as an AND of clauses, each of which is the OR of one or more literals \cite{CLRS01}. A Boolean formula is in 3-conjunctive normal form or $3CNF$, if each clause has exactly three distinct literals \cite{CLRS01}.

For example, the Boolean formula:
\[(x_{1} \vee \rightharpoondown x_{1} \vee \rightharpoondown x_{2}) \wedge (x_{3} \vee x_{2} \vee x_{4}) \wedge (\rightharpoondown x_{1} \vee \rightharpoondown x_{3} \vee \rightharpoondown x_{4})\]
is in $3CNF$. The first of its three clauses is $(x_{1} \vee \rightharpoondown x_{1} \vee \rightharpoondown x_{2})$, which contains the three literals $x_{1}$, $\rightharpoondown x_{1}$, and $\rightharpoondown x_{2}$. Another relevant $\textit{NP--complete}$ language is $3CNF$ satisfiability, or $3SAT$ \cite{CLRS01}. In $3SAT$, it is asked whether a given Boolean formula $\phi$ in $3CNF$ is satisfiable.

A logarithmic space Turing machine has a read-only input tape, a write-only output tape, and read/write work tapes \cite{MS06}. The work tapes may contain at most $O(\log n)$ symbols \cite{MS06}. In computational complexity theory, $L$ is the complexity class containing those decision problems that can be decided by a deterministic logarithmic space Turing machine \cite{Pap03}. $NL$ is the complexity class containing the decision problems that can be decided by a nondeterministic logarithmic space Turing machine \cite{Pap03}.

A logarithmic space transducer is a Turing machine with a read-only input tape, a write-only output tape, and read/write work tapes \cite{MS06}. The work tapes must contain at most $O(\log n)$ symbols \cite{MS06}. A logarithmic space transducer $M$ computes a function $f : \Sigma^{*} \rightarrow \Sigma^{*}$, where $f(w)$ is the string remaining on the output tape after $M$ halts when it is started with $w$ on its input tape \cite{MS06}. We call $f$ a logarithmic space computable function \cite{MS06}. We say that a language $L_{1} \subseteq \{0, 1\}^{*}$ is logarithmic space reducible to a language $L_{2} \subseteq \{0, 1\}^{*}$, written $L_{1} \leq_{l} L_{2}$, if there exists a logarithmic space computable function $f : \{0, 1\}^{*} \rightarrow \{0, 1\}^{*}$ such that for all $x \in \{0, 1\}^{*}$:
\[x \in L_{1} \textit{ if and only if } f(x) \in L_{2}.\]
The logarithmic space reduction is used in the definition of the complete languages for the classes $L$ and $NL$ \cite{Pap03}. A Boolean formula is in 2-conjunctive normal form, or $2CNF$, if it is in $CNF$ and each clause has exactly two distinct literals. There is a problem called $2SAT$, where we asked whether a given Boolean formula $\phi$ in $2CNF$ is satisfiable. $2SAT$ is complete for $NL$ \cite{Pap03}. Another special case is the class of problems where each clause contains $XOR$ (i.e. exclusive or) rather than (plain) $OR$ operators. This is in $P$, since an $\textit{XOR SAT}$ formula can also be viewed as a system of linear equations mod $2$, and can be solved in cubic time by Gaussian elimination \cite{MM11}. We denote the $XOR$ function as $\oplus$. The $\textit{XOR 2SAT}$ problem will be equivalent to $\textit{XOR SAT}$, but the clauses in the formula have exactly two distinct literals. $\textit{XOR 2SAT}$ is in $L$ \cite{AR00}, \cite{RM08}.

We can give a certificate-based definition for $NL$ \cite{AB09}. The certificate-based definition of $NL$ assumes that a logarithmic space Turing machine has another separated read-only tape \cite{AB09}. On each step of the machine, the machine's head on that tape can either stay in place or move to the right \cite{AB09}. In particular, it cannot reread any bit to the left of where the head currently is \cite{AB09}. For that reason this kind of special tape is called $``$read-once$"$ \cite{AB09}. Besides, in the certificate-based definition of $NL$, we assume the certificate string is appropriated for the instance \cite{Pap03}. For example, a truth assignment for a Boolean formula $\phi$ is appropriated for the instance when every possible variable in $\phi$ could be evaluated in that truth assignment string, but we cannot affirm the same for every possible binary string.

\begin{definition}
A language $L_{1}$ is in $NL$ if there exists a deterministic logarithmic space Turing machine $M$ with an additional special read-once input tape polynomial $p: \mathbb{N} \rightarrow \mathbb{N}$ such that for every $x \in \{0, 1\}^{*}$:
\[x \in L_{1} \Leftrightarrow \exists \textit{ appropriated } u \in \{0, 1\}^{p(|x|)} \textit{ such that } M(x, u) = 1 \]
where by $M(x, u)$ we denote the computation of $M$ where $x$ is placed on its input tape and the certificate $u$ is placed on its special read-once tape, and $M$ uses at most $O(\log |x|)$ space on its read/write tapes for every input $x$ where $|\ldots|$ is the bit-length function \cite{AB09}. $M$ is called a logarithmic space verifier \cite{AB09}.
\end{definition}

We state the following Hypothesis:

\begin{hypothesis}
\label{hypothesis1}
Given a nonempty language $L_{1} \in L$, there is a language $L_{2}$ in $\textit{NP--complete}$ with a deterministic Turing machine $M$, where:
\[L_{2} = \{w: M(w, u) = y, \exists \textit{ appropriated } u \textit{ such that } y \in L_{1}\}\]
when $M$ runs in logarithmic space in the length of $w$, $u$ is placed on the special read-once tape of $M$, and $u$ is polynomially bounded by $w$. In this way, there is an $\textit{NP--complete}$ language defined by a logarithmic space verifier $M$ such that when the input is an element of the language with its certificate, then $M$ outputs a string which belongs to a single language in $L$.
\end{hypothesis}

\begin{theorem}
\label{implication}
When the Hypothesis \ref{hypothesis1} is true, therefore if $L_{2}$ is $\textit{NP--complete}$ under logarithmic space reduction, then $NL = NP$.
\end{theorem}

\begin{proof}
Since every problem in $L$ is $\textit{L--complete}$ under logarithmic space reduction, then we can interpret the quantification of the above statement as $``$For any nonempty language $L_{1}$ in $L$, there is an $\textit{NP--complete}$ language $L_{2}$ $\ldots$ (rest is the same)$"$. However, if we can choose an arbitrary language $L_{1}$ in $L$, then choosing $L_{1}$ the trivial language $\{1\}$ will result in the right hand side of the expression defining $L_{2}$ contained in $NL$. Moreover, if that problem in $NL$ is $\textit{NP--complete}$ under logarithmic space reduction, then we obtain that certainly $NL = NP$.
\end{proof}

\section{Results}

We show a previous known $\textit{NP--complete}$ problem:

\begin{definition}
$\textbf{NAE 3SAT}$

INSTANCE: A Boolean formula $\phi$ in $3CNF$.

QUESTION: Is there a truth assignment for $\phi$ such that each clause has at least one true literal and at least one false literal?

REMARKS: $\textit{NAE 3SAT} \in \textit{NP--complete}$ \cite{GJ79}.
\end{definition}

We define a new problem:

\begin{definition}
$\textbf{MAXIMUM EXCLUSIVE-OR 2SAT}$

INSTANCE: A positive integer $K$ and a Boolean formula $\phi$ that is an instance of $\textit{XOR 2SAT}$.

QUESTION: Is there a truth assignment in $\phi$ such that at most $K$ clauses are unsatisfied?

REMARKS: We denote this problem as $MAX\oplus2SAT$.
\end{definition}

\begin{theorem}
\label{completeness}
$MAX\oplus2SAT \in \textit{NP--complete}$.
\end{theorem}

\begin{proof}
It is trivial to see $MAX\oplus2SAT \in NP$ \cite{Pap03}. Given a Boolean formula $\phi$ in $3CNF$ with $n$ variables and $m$ clauses, we create three new variables $a_{c_{i}}$, $b_{c_{i}}$ and $d_{c_{i}}$ for each clause $c_{i} = (x \vee y \vee z)$ in $\phi$, where $x$, $y$ and $z$ are literals, in the following formula:
\[P_{i} = (a_{c_{i}} \oplus b_{c_{i}}) \wedge (b_{c_{i}} \oplus d_{c_{i}}) \wedge (a_{c_{i}} \oplus d_{c_{i}}) \wedge (x \oplus a_{c_{i}}) \wedge (y \oplus b_{c_{i}}) \wedge (z \oplus d_{c_{i}}).\]
We can see $P_{i}$ has at most one unsatisfied clause for some truth assignment if and only if at least one member of $\{x,y,z\}$ is true and at least one member of $\{x,y,z\}$ is false for the same truth assignment. Hence, we can create the Boolean formula $\psi$ as the conjunction of the $P_{i}$ formulas for every clause $c_{i}$ in $\phi$, such that $\psi = P_{1} \wedge \ldots \wedge P_{m}$. Finally, we obtain that:
\[\phi \in \textit{NAE 3SAT} \textit{ if and only if } (\psi, m) \in MAX\oplus2SAT.\]
Consequently, we prove $\textit{NAE 3SAT} \leq_{p} MAX\oplus2SAT$ where we already know the language $\textit{NAE 3SAT} \in \textit{NP--complete}$ \cite{GJ79}. To sum up, we show $MAX\oplus2SAT \in \textit{NP--hard}$ and $MAX\oplus2SAT \in NP$ and thus, $MAX\oplus2SAT \in \textit{NP--complete}$.
\end{proof}

\begin{theorem}
\label{proof}
There is a deterministic Turing machine $M$, where:
\[MAX\oplus2SAT = \{w: M(w, u) = y, \exists \textit{ appropriated } u \textit{ such that } y \in \textit{XOR 2SAT}\}\]
when $M$ runs in logarithmic space in the length of $w$, $u$ is placed on the special read-once tape of $M$, and $u$ is polynomially bounded by $w$.
\end{theorem}

\begin{proof}
Given a valid instance $(\psi, K)$ for $MAX\oplus2SAT$ when $\psi$ has $m$ clauses, we can create a certificate array $A$ which contains $K$ different natural numbers in ascending order which represents the indexes of the clauses in $\psi$ that we are going to remove from the instance. We read at once the elements of the array $A$ and we reject whether this is not an appropriated certificate: That is when the numbers are not sorted in ascending order, or the array $A$ does not contain exactly $K$ elements, or the array $A$ contains a number that is not between $1$ and $m$. While we read the elements of the array $A$, we remove the clauses from the instance $(\psi, K)$ for $MAX\oplus2SAT$ just creating another instance $\phi$ for $\textit{XOR 2SAT}$ where the Boolean formula $\phi$ does not contain the $K$ different indexed clauses $\psi$ represented by the numbers in $A$. Therefore, we obtain the array $A$ would be valid according to the Theorem \ref{proof} when:
\[(\psi, K) \in MAX\oplus2SAT \Leftrightarrow (\exists \textit{ appropriated array } A \textit{ such that } \phi \in \textit{XOR 2SAT}).\]
Furthermore, we can make this verification in logarithmic space such that the array $A$ is placed on the special read-once tape, because we read at once the elements in the array $A$ and we assume the clauses in the input $\psi$ are indexed from left to right. Hence, we only need to iterate from the elements of the array $A$ to verify whether the array is an appropriated certificate and also remove the $K$ different clauses from the Boolean formula $\psi$ when we write the final clauses to the output. This logarithmic space verification will be the Algorithm \ref{algorithm1}. We assume whether a value does not exist in the array $A$ into the cell of some position $i$ when $A[i] = \textit{undefined}$. In addition, we reject immediately when the following comparisons:
\[A[i] \leq max \vee A[i] < 1 \vee A[i] > m\]
hold at least into one single binary digit. Note, in the loop $j$ from $min$ to $max - 1$, we do not output any clause when $max - 1 < min$.

\begin{algorithm}
\caption{Logarithmic space verifier}\label{algorithm1}
\begin{algorithmic}[1]
\Comment{A valid instance for $MAX\oplus2SAT$ with its certificate}
\Procedure{$\textit{VERIFIER}$}{$(\psi, K), A$}
\Comment{Initialize minimum and maximum values}
\State $min \gets 1$
\State $max \gets 0$
\Comment{Iterate for the elements of the certificate array $A$}
\For{$i$}{$1$}{$K + 1$}
\If{$i = K+1$}
\Comment{There exists a $K+1$ element in the array}
\If{$A[i] \neq \textit{undefined}$}
\Comment{Reject the certificate}
\State \textbf{return} $0$
\EndIf
\Comment{$m$ is the number of clauses in $\psi$}
\State $max \gets m + 1$
\ElsIf{$A[i] = \textit{undefined} \vee A[i] \leq max \vee A[i] < 1 \vee A[i] > m$}
\Comment{Reject the certificate}
\State \textbf{return} $0$
\Else
\State $max \gets A[i]$
\EndIf
\Comment{Iterate for the clauses of the Boolean formula $\psi$}
\For{$j$}{$min$}{$max - 1$}
\Comment{Output the indexed $j^{th}$ clause in $\psi$}
\State \textbf{output} $``\wedge c_{j}"$
\EndFor
\State $min \gets max + 1$
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
\end{proof}

\begin{theorem}
\label{result1}
The Hypothesis \ref{hypothesis1} is true.
\end{theorem}

\begin{proof}
This is a consequence of Theorems \ref{completeness} and \ref{proof}.
\end{proof}

\begin{theorem}
\label{nl}
$NL = NP$ and thus, $P = NP$.
\end{theorem}

\begin{proof}
The Hypothesis \ref{hypothesis1} is true according to Theorem \ref{proof}. Since the polynomial time reduction in Theorem \ref{completeness} could be easily transformed in a logarithmic space reduction, then the $\textit{NP--complete}$ problem in Hypothesis \ref{hypothesis1}, that would be $MAX\oplus2SAT$, is necessarily in $NL$ and thus all the problems in $NP$, because of the Cook's Theorem can also be transformed in a logarithmic space reduction \cite{GJ79}. Certainly, every $NP$ problem could be logarithmic space reduced to $SAT$ by the Cook's Theorem algorithm and $SAT$ can be indeed logarithmic space reduced to $\textit{NAE 3SAT}$ \cite{GJ79}. In addition, as a consequence of Theorem \ref{completeness}, the problem $\textit{NAE 3SAT}$ could be logarithmic space reduced to $MAX\oplus2SAT$. In this way, we obtain that $NL = NP$ as result of Theorem \ref{implication}. Since $NL \subseteq P$, then $P = NP$ \cite{Pap03}.
\end{proof}

\section{Conclusions}

No one has been able to find a polynomial time algorithm for any of more than $300$ important known $\textit{NP--complete}$ problems \cite{GJ79}. A proof of $P = NP$ will have stunning practical consequences, because it leads to efficient methods for solving some of the important problems in $NP$ \cite{CS00}. The consequences, both positive and negative, arise since various $\textit{NP--complete}$ problems are fundamental in many fields \cite{CS00}. The following consequences are assuming that we have a practical solution for the $\textit{NP--complete}$ problems where such existence was proven with our nonconstructive result:

Cryptography, for example, relies on certain problems being difficult. A constructive and efficient solution to an $\textit{NP--complete}$ problem such as $3SAT$ will break most existing cryptosystems including: Public-key cryptography \cite{HW97}, symmetric ciphers \cite{MM00} and one-way functions used in cryptographic hashing \cite{DKV07}. These would need to be modified or replaced by information-theoretically secure solutions not inherently based on $\textit{P--NP}$ equivalence.

There are enormous positive consequences that will follow from rendering tractable many currently mathematically intractable problems. For instance, many problems in operations research are $\textit{NP--complete}$, such as some types of integer programming and the traveling salesman problem \cite{GJ79}. Efficient solutions to these problems have enormous implications for logistics \cite{CS00}. Many other important problems, such as some problems in protein structure prediction, are also $\textit{NP--complete}$, so this will spur considerable advances in biology \cite{BL98}.

Since all the $\textit{NP--complete}$ optimization problems become easy, everything will be much more efficient \cite{LF09}. Transportation of all forms will be scheduled optimally to move people and goods around quicker and cheaper \cite{LF09}. Manufacturers can improve their production to increase speed and create less waste \cite{LF09}. Learning becomes easy by using the principle of Occam's razor: We simply find the smallest program consistent with the data \cite{LF09}. Near perfect vision recognition, language comprehension and translation and all other learning tasks become trivial \cite{LF09}. We will also have much better predictions of weather and earthquakes and other natural phenomenon \cite{LF09}.

There would be disruption, including maybe displacing programmers \cite{IMP95}. The practice of programming itself would be more about gathering training data and less about writing code \cite{IMP95}. Google would have the resources to excel in such a world \cite{IMP95}.

But such changes may pale in significance compared to the revolution an efficient method for solving $\textit{NP--complete}$ problems will cause in mathematics itself \cite{CS00}. Research mathematicians spend their careers trying to prove theorems, and some proofs have taken decades or even centuries to find after problems have been stated \cite{AS17}. For instance, Fermat's Last Theorem took over three centuries to prove \cite{AS17}. A method that is guaranteed to find proofs to theorems, should one exist of a $``$reasonable$"$ size, would essentially end this struggle \cite{CS00}.

\bibliography{manuscript}


\end{document}
