
\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"

\usepackage{url}
\usepackage{algpseudocode}
\usepackage{algorithm}
\algrenewcommand{\algorithmiccomment}[1]{\State /*#1*/}
\algnewcommand\algorithmicto{$\textbf{to}$}
\algrenewtext{For}[3]{\algorithmicfor\ #1 $\gets$ #2 \algorithmicto\ #3 \algorithmicdo}
\newtheorem{hypothesis}[theorem]{Hypothesis}

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Logarithmic Space Verifiers on NP-complete} %TODO Please add

%\titlerunning{P vs NP}%optional, please use if title is longer than one line

\author{Frank Vega}{Joysonic, Uzun Mirkova 5, Belgrade, 11000, Serbia} {vega.frank@gmail.com}{https://orcid.org/0000-0001-8210-4126}{}


\authorrunning{F. Vega}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

%\Copyright{John Q. Public and Joan R. Public}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Complexity classes}
\ccsdesc[300]{Theory of computation~Problems, reductions and completeness}
%\ccsdesc[100]{Mathematics of computing~Number-theoretic computations}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{complexity classes, completeness, verifier, reduction, polynomial time, logarithmic space}%TODO mandatory; please add comma-separated list of keywords

%\category{}%optional, e.g. invited paper

%\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{https://www.academia.edu/39721020/Solution_of_the_P_versus_NP_Problem}.}

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

\nolinenumbers %uncomment to disable line numbering

\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\EventEditors{John Q. Open and Joan R. Access}
%\EventNoEds{2}
%\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
%\EventShortTitle{CVIT 2016}
%\EventAcronym{CVIT}
%\EventYear{2016}
%\EventDate{December 24--27, 2016}
%\EventLocation{Little Whinging, United Kingdom}
%\EventLogo{}
%\SeriesVolume{42}
%\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
P versus NP is considered as one of the most important open problems in computer science. This consists in knowing the answer of the following question: Is P equal to NP? A precise statement of the P versus NP problem was introduced independently by Stephen Cook and Leonid Levin. Since that date, all efforts to find a proof for this problem have failed. NP is the complexity class of languages defined by polynomial time verifiers M such that when the input is an element of the language with its certificate, then M outputs a string which belongs to a single language in P. Another major complexity classes are L and NL. The certificate-based definition of NL is based on logarithmic space Turing machine with an additional special read-once input tape: This is called a logarithmic space verifier. NL is the complexity class of languages defined by logarithmic space verifiers M such that when the input is an element of the language with its certificate, then M outputs 1. To attack the P versus NP problem, the NP-completeness is a useful concept. We demonstrate there is an NP-complete language defined by a logarithmic space verifier M such that when the input is an element of the language with its certificate, then M outputs a string which belongs to a single language in L. In this way, we obtain if L is not equal to NL, then P = NP. In addition, we show that L is not equal to NL. Hence, we prove the complexity class P is equal to NP.
\end{abstract}

\section{Introduction}

In previous years there has been great interest in the verification or checking of computations \cite{LIP90}. Interactive proofs introduced by Goldwasser, Micali and Rackoff and Babi can be viewed as a model of the verification process \cite{LIP90}. Dwork and Stockmeyer and Condon have studied interactive proofs where the verifier is a space bounded computation instead of the original model where the verifer is a time bounded computation \cite{LIP90}. In addition, Blum and Kannan has studied another model where the goal is to check a computation based solely on the final answer \cite{LIP90}. More about probabilistic logarithmic space verifiers have been shown on a technique of Lipton \cite{LIP90}. In this work, we show some results about the logarithmic space verifiers applied to the class $NP$ which solve one of the most important open problems in computer science, that is $P$ versus $NP$.

The $P$ versus $NP$ problem is a major unsolved problem in computer science \cite{CS00}. This is considered by many to be the most important open problem in the field \cite{CS00}. It is one of the seven Millennium Prize Problems selected by the Clay Mathematics Institute to carry a US\$1,000,000 prize for the first correct solution \cite{CS00}. It was essentially mentioned in 1955 from a letter written by John Nash to the United States National Security Agency \cite{AS17}. However, the precise statement of the $P=NP$ problem was introduced in 1971 by Stephen Cook in a seminal paper \cite{CS00}. In 2012, a poll of 151 researchers showed that 126 (83\%) believed the answer to be no, 12 (9\%) believed the answer is yes, 5 (3\%) believed the question may be independent of the currently accepted axioms and therefore impossible to prove or disprove, 8 (5\%) said either do not know or do not care or don't want the answer to be yes nor the problem to be resolved \cite{GA12}. It is fully expected that $P \neq NP$ \cite{Pap03}. Indeed, if $P = NP$ then there are stunning practical consequences \cite{Pap03}. For that reason, $P = NP$ is considered as a very unlikely event \cite{Pap03}. Certainly, $P$ versus $NP$ is one of the greatest open problems in science and a correct solution for this incognita will have a great impact not only in computer science, but for many other fields as well \cite{AS17}. Whether $P = NP$ or not is still a controversial and unsolved problem \cite{AS17}. We show some results that prove this outstanding problem with the unexpected solution of $P = NP$.

\section{Materials and Methods}

\subsection{Preliminaries}

In 1936, Turing developed his theoretical computational model \cite{MS06}. The deterministic and nondeterministic Turing machines have become in two of the most important definitions related to this theoretical model for computation \cite{MS06}. A deterministic Turing machine has only one next action for each step defined in its program or transition function \cite{MS06}. A nondeterministic Turing machine could contain more than one action defined for each step of its program, where this one is no longer a function, but a relation \cite{MS06}.

Let $\Sigma$ be a finite alphabet with at least two elements, and let $\Sigma^{*}$ be the set of finite strings over $\Sigma$ \cite{AB09}. A Turing machine $M$ has an associated input alphabet $\Sigma$ \cite{AB09}. For each string $w$ in $\Sigma^{*}$ there is a computation associated with $M$ on input $w$ \cite{AB09}. We say that $M$ accepts $w$ if this computation terminates in the accepting state, that is $M(w)=1$ (when $M$ outputs 1 on the input $w$) \cite{AB09}. Note that $M$ fails to accept $w$ either if this computation ends in the rejecting state, that is $M(w)=0$, or if the computation fails to terminate, or the computation ends in the halting state with some output, that is $M(w)=y$ (when $M$ outputs the string $y$ on the input $w$) \cite{AB09}.

Another relevant advance in the last century has been the definition of a complexity class. A language over an alphabet is any set of strings made up of symbols from that alphabet \cite{CLRS01}. A complexity class is a set of problems, which are represented as a language, grouped by measures such as the running time, memory, etc \cite{CLRS01}. The language accepted by a Turing machine $M$, denoted $L(M)$, has an associated alphabet $\Sigma$ and is defined by:
\[L(M) = \{w \in \Sigma^{*}: M(w)=1 \}.\]
We denote by $t_{M}(w)$ the number of steps in the computation of $M$ on input $w$ \cite{AB09}. For $n \in \mathbb{N}$ we denote by $T_{M}(n)$ the worst case run time of $M$; that is:
\[T_{M}(n) = max\{t_{M}(w): w \in \Sigma^{n} \}\]
where $\Sigma^{n}$ is the set of all strings over $\Sigma$ of length $n$ \cite{AB09}. We say that $M$ runs in polynomial time if there is a constant $k$ such that for all $n$, $T_{M}(n) \leq n^{k} + k$ \cite{AB09}. In other words, this means the language $L(M)$ can be decided by the Turing machine $M$ in polynomial time. Therefore, $P$ is the complexity class of languages that can be decided by deterministic Turing machines in polynomial time \cite{CLRS01}. A verifier for a language $L_{1}$ is a deterministic Turing machine $M$, where:
\[L_{1} = \{w: M(w, c) = 1 \textit{ for some string } c\}.\]
We measure the time of a verifier only in terms of the length of $w$, so a polynomial time verifier runs in polynomial time in the length of $w$ \cite{AB09}. A verifier uses additional information, represented by the symbol $c$, to verify that a string $w$ is a member of $L_{1}$. This information is called certificate. $NP$ is the complexity class of languages defined by polynomial time verifiers \cite{Pap03}.

\begin{lemma}
\label{verifier}
Given a language $L_{1} \in P$, a language $L_{2}$ is in $NP$ if there is a deterministic Turing machine $M$, where:
\[L_{2} = \{w: M(w, c) = y \textit{ for some string } c \textit{ such that } y \in L_{1}\}\]
and $M$ runs in polynomial time in the length of $w$. In this way, $NP$ is the complexity class of languages defined by polynomial time verifiers $M$ such that when the input is an element of the language with its certificate, then $M$ outputs a string which belongs to a single language in $P$.
\end{lemma}

\begin{proof}
If $L_{1}$ can be decided by the Turing machine $M'$ in polynomial time, then the deterministic Turing machine $M''(w, c) = M'(M(w, c))$ will output 1 when $w \in L_{2}$. Consequently, $M''$ is a polynomial time verifier of $L_{2}$ and thus, $L_{2}$ is in $NP$.
\end{proof}

\subsection{Hypothesis}

A function $f : \Sigma^{*} \rightarrow \Sigma^{*}$ is a polynomial time computable function if some deterministic Turing machine $M$, on every input $w$, halts in polynomial time with just $f(w)$ on its tape \cite{MS06}. Let $\{0, 1\}^{*}$ be the infinite set of binary strings, we say that a language $L_{1} \subseteq \{0, 1\}^{*}$ is polynomial time reducible to a language $L_{2} \subseteq \{0, 1\}^{*}$, written $L_{1} \leq_{p} L_{2}$, if there is a polynomial time computable function $f : \{0, 1\}^{*} \rightarrow \{0, 1\}^{*}$ such that for all $x \in \{0, 1\}^{*}$:
\[x \in L_{1} \textit{ if and only if } f(x) \in L_{2}.\]
An important complexity class is $\textit{NP--complete}$ \cite{GJ79}. A language $L_{1} \subseteq \{0, 1\}^{*}$ is $\textit{NP--complete}$ if:

\begin{itemize}
\item $L_{1} \in NP$, and
\item $L' \leq_{p} L_{1}$ for every $L' \in NP$.
\end{itemize}

If $L_{1}$ is a language such that $L' \leq_{p} L_{1}$ for some $L' \in \textit{NP--complete}$, then $L_{1}$ is $\textit{NP--hard}$ \cite{CLRS01}. Moreover, if $L_{1} \in NP$, then $L_{1} \in \textit{NP--complete}$ \cite{CLRS01}. A principal $\textit{NP--complete}$ problem is $SAT$ \cite{GJ79}. An instance of $SAT$ is a Boolean formula $\phi$ which is composed of:

\begin{enumerate}
\item Boolean variables: $x_{1}, x_{2},\ldots, x_{n}$;
\item Boolean connectives: Any Boolean function with one or two inputs and one output, such as $\wedge$(AND), $\vee$(OR), $\rightharpoondown$(NOT), $\Rightarrow$(implication), $\Leftrightarrow$(if and only if);
\item and parentheses.
\end{enumerate}

A truth assignment for a Boolean formula $\phi$ is a set of values for the variables in $\phi$. A satisfying truth assignment is a truth assignment that causes $\phi$ to be evaluated as true. A formula with a satisfying truth assignment is a satisfiable formula. The problem $SAT$ asks whether a given Boolean formula is satisfiable \cite{GJ79}. We define a $CNF$ Boolean formula using the following terms:

A literal in a Boolean formula is an occurrence of a variable or its negation \cite{CLRS01}. A Boolean formula is in conjunctive normal form, or $CNF$, if it is expressed as an AND of clauses, each of which is the OR of one or more literals \cite{CLRS01}. A Boolean formula is in 3-conjunctive normal form or $3CNF$, if each clause has exactly three distinct literals \cite{CLRS01}.

For example, the Boolean formula:
\[(x_{1} \vee \rightharpoondown x_{1} \vee \rightharpoondown x_{2}) \wedge (x_{3} \vee x_{2} \vee x_{4}) \wedge (\rightharpoondown x_{1} \vee \rightharpoondown x_{3} \vee \rightharpoondown x_{4})\]
is in $3CNF$. The first of its three clauses is $(x_{1} \vee \rightharpoondown x_{1} \vee \rightharpoondown x_{2})$, which contains the three literals $x_{1}$, $\rightharpoondown x_{1}$, and $\rightharpoondown x_{2}$. Another relevant $\textit{NP--complete}$ language is $3CNF$ satisfiability, or $3SAT$ \cite{CLRS01}. In $3SAT$, it is asked whether a given Boolean formula $\phi$ in $3CNF$ is satisfiable.

A logarithmic space Turing machine has a read-only input tape, a write-only output tape, and read/write work tapes \cite{MS06}. The work tapes may contain at most $O(\log n)$ symbols \cite{MS06}. In computational complexity theory, $L$ is the complexity class containing those decision problems that can be decided by a deterministic logarithmic space Turing machine \cite{Pap03}. $NL$ is the complexity class containing the decision problems that can be decided by a nondeterministic logarithmic space Turing machine \cite{Pap03}.

A logarithmic space transducer is a Turing machine with a read-only input tape, a write-only output tape, and read/write work tapes \cite{MS06}. The work tapes must contain at most $O(\log n)$ symbols \cite{MS06}. A logarithmic space transducer $M$ computes a function $f : \Sigma^{*} \rightarrow \Sigma^{*}$, where $f(w)$ is the string remaining on the output tape after $M$ halts when it is started with $w$ on its input tape \cite{MS06}. We call $f$ a logarithmic space computable function \cite{MS06}. We say that a language $L_{1} \subseteq \{0, 1\}^{*}$ is logarithmic space reducible to a language $L_{2} \subseteq \{0, 1\}^{*}$, written $L_{1} \leq_{l} L_{2}$, if there exists a logarithmic space computable function $f : \{0, 1\}^{*} \rightarrow \{0, 1\}^{*}$ such that for all $x \in \{0, 1\}^{*}$,
\[x \in L_{1} \textit{ if and only if } f(x) \in L_{2}.\]
The logarithmic space reduction is frequently used for $L$ and $NL$ \cite{Pap03}. On the one hand, we call the deterministic logarithmic space reduction as $\textit{L--reduction}$. On the other hand, we call the nondeterministic logarithmic space reduction as $\textit{NL--reduction}$.

A Boolean formula is in 2-conjunctive normal form, or $2CNF$, if it is in $CNF$ and each clause has exactly two distinct literals. There is a problem called $2SAT$, where we asked whether a given Boolean formula $\phi$ in $2CNF$ is satisfiable. $2SAT$ is complete for $NL$ \cite{Pap03}. Another special case is the class of problems where each clause contains $XOR$ (i.e. exclusive or) rather than (plain) $OR$ operators. This is in $P$, since an $\textit{XOR SAT}$ formula can also be viewed as a system of linear equations mod $2$, and can be solved in cubic time by Gaussian elimination \cite{MM11}. We denote the $XOR$ function as $\oplus$. The $\textit{XOR 2SAT}$ problem will be equivalent to $\textit{XOR SAT}$, but the clauses in the formula have exactly two distinct literals. $\textit{XOR 2SAT}$ is in $L$ \cite{AR00}, \cite{RM08}.

We can give a certificate-based definition for $NL$ \cite{AB09}. The certificate-based definition of $NL$ assumes that a logarithmic space Turing machine has another separated read-only tape \cite{AB09}. On each step of the machine the machine's head on that tape can either stay in place or move to the right \cite{AB09}. In particular, it cannot reread any bit to the left of where the head currently is \cite{AB09}. For that reason this kind of special tape is called ``read once" \cite{AB09}.

\begin{definition}
A language $L_{1}$ is in $NL$ if there exists a deterministic logarithmic space Turing machine $M$ with an additional special read-once input tape polynomial $p: \mathbb{N} \rightarrow \mathbb{N}$ such that for every $x \in \{0, 1\}^{*}$,
\[x \in L_{1} \Leftrightarrow \exists u \in \{0, 1\}^{p(|x|)} \textit{ such that } M(x, u) = 1 \]
where by $M(x, u)$ we denote the computation of $M$ where $x$ is placed on its input tape and $u$ is placed on its special read-once tape, and $M$ uses at most $O(\log |x|)$ space on its read/write tapes for every input $x$ where $|\ldots|$ is the bit-length function \cite{AB09}. $M$ is called a logarithmic space verifier \cite{AB09}.
\end{definition}

We state the following Hypothesis:

\begin{hypothesis}
\label{hypothesis}
Given a language $L_{1} \in L$, there is a language $L_{2}$ in $\textit{NP--complete}$ with a deterministic Turing machine $M$, where:
\[L_{2} = \{w: M(w, u) = y \textit{ for some string } u \textit{ such that } y \in L_{1}\}\]
when $M$ runs in logarithmic space in the length of $w$, $u$ is placed on the special read-once tape of $M$, and $u$ is polynomially bounded by $w$. In this way, there is an $\textit{NP--complete}$ language defined by a logarithmic space verifier $M$ such that when the input is an element of the language with its certificate, then $M$ outputs a string which belongs to a single language in $L$.
\end{hypothesis}

\subsection{Consequences}

From the early days of automata and complexity  theory,  two  different  models  of  Turing  machines  are  considered, the offline and online machines \cite{KU15}. Each model has a read-only input tape and some work tapes \cite{KU15}. The offline machines may read their input two-way while the online machines are not allowed to move the input head to the left \cite{KU15}. In the terminology of the (generalized) Turing machine models are called two-way and one-way Turing machines, respectively \cite{KU15}.

Hartmanis and Mahaney have investigated the classes $1L$ and $1NL$ of languages recognizable by deterministic one-way logarithmic space Turing machine and nondeterministic one-way logarithmic space Turing machine, respectively \cite{HM81}. They have shown that $1L \neq 1NL$ (by looking at a uniform variant of the string non-equality problem from communication complexity theory) and have defined a natural complete problem for $1NL$ under deterministic one-way logarithmic space reductions \cite{HM81}. Furthermore, they have proven that $1NL \subseteq L$ if and only if $L=NL$ \cite{HM81}.

\begin{theorem}
\label{implication}
If the Hypothesis \ref{hypothesis} is true, therefore if $L \neq NL$, then $P = NP$.
\end{theorem}

\begin{proof}
We can simulate the computation $M(w, u) = y$ in the Hypothesis \ref{hypothesis} by a nondeterministic logarithmic space Turing machine $N$, such that $N(w) = y$ since we can read the certificate string $u$ within the read-once tape by a work tape in a nondeterministic logarithmic space generation of symbols contained in $u$ \cite{Pap03}. Certainly, we can simulate the reading of one symbol from the string $u$ into the read-once tape just nondeterministically generating the same symbol in the work tapes using a logarithmic space \cite{Pap03}.

If we suppose that $L \subset 1NL$, then we can accept the elements of the language $L_{1} \in L$ by a nondeterministic one-way logarithmic space Turing machine $M'$. In this way, there is a nondeterministic logarithmic space Turing machine $M''(w) = M'(N(w))$ which will output 1 when $w \in L_{2}$. Consequently, $M''$ is a nondeterministic logarithmic space Turing machine which decides the language $L_{2}$. The reason is because we can simulate the output string of $N(w)$ within a read-once tape and thus, we can compute in a nondeterministic logarithmic space the logarithmic space composition using the same techniques of the logarithmic space composition reduction, but without any reset of the computation \cite{Pap03}. Certainly, we do not need to reset the computation of $N(w)$ for the reading at once of a symbol in the output string of $N(w)$ by the nondeterministic one-way logarithmic space Turing machine $M'$. Therefore, $L_{2}$ is in $NL$ and thus, $L_{2} \in P$ due to $NL \subseteq P$ \cite{Pap03}. If any single $\textit{NP--complete}$ problem can be solved in polynomial time, then $P = NP$ \cite{CLRS01}. Since $L_{2} \in P$ and $L_{2} \in \textit{NP--complete}$, then we obtain the complexity class $P$ is equal to $NP$ under the assumption that $L \subset 1NL$.

Hartmanis and Mahaney have also shown with their result that if $1NL \subseteq L$ or even $1NL \subset L$, then $L=NL$, because they proved there is a complete problem for both $1NL$ and $NL$ at the same time \cite{HM81}. If this way, if $L \neq NL$, then $L \subset 1NL$ by contraposition \cite{Pap03}. Since we already obtained that $P = NP$ under the assumption that $L \subset 1NL$, therefore if $L \neq NL$, then $P = NP$.
\end{proof}

Now, we define two classes defined under $\textit{L--reduction}$ and $\textit{NL--reduction}$, respectively.

\begin{definition}
The class $2L$ contains those languages that are deterministic logarithmic space reduced to a language in $1L$. The class $2NL$ consists in those languages that are nondeterministic logarithmic space reduced to a language in $1NL$.
\end{definition}

Let $\textit{1TAPE}[T(n)]$ denote the family of languages accepted by deterministic one-way Turing machines with $T(n)$ work tape \cite{HM81}.

\begin{theorem}
\label{closed}
If $T(n)$ is such that
\[\lim_{n\to\infty} \frac{T(n)}{n} = 0\]
then $\textit{1TAPE}[T(n)]$ is closed under deterministic two-way logarithmic space reduction.
\end{theorem}

\begin{proof}
Suppose that $\textit{1TAPE}[T'(n)]$ is not closed under deterministic two-way logarithmic space reduction for some $T'(n)$ when
\[\lim_{n\to\infty} \frac{T'(n)}{n} = 0.\]
Hence, the family of languages $\textit{1TAPE}[T'(n)]$ is two-way logarithmic space reduced to the another family of languages $\textit{1TAPE}[T'(n) - H(n)]$ where the deterministic two-way logarithmic space reduction consumes at most $H(n)$ in the work tapes. Consequently, for each instance of a language in $\textit{1TAPE}[T'(n)]$ of size $n$, then this could be equivalent to another instance of size with at most $G(n) \times n$ symbols for some function $G(n) > 1$, that is the result of reading consecutively the symbols in the input tape in a sequential way. This means if during the deterministic two-way logarithmic space reduction the input head moves to the left or to the right, then this is a new symbol that appears contiguously to the right in the instance of size at most $G(n) \times n$. However, we know in that instance of size at most $G(n) \times n$, we can replace the deterministic two-way logarithmic space reduction by a deterministic one-way logarithmic space reduction that read contiguously from left-to-right. Therefore, the instance of size at most $G(n) \times n$ could be decided by a deterministic one-way logarithmic space Turing machine that simulates the two-way logarithmic space reduction with at most $H(n)$ in the work tapes within the composition on the another deterministic one-way logarithmic space Turing machine which is used in $\textit{1TAPE}[T'(n) - H(n)]$ after the deterministic two-way logarithmic space reduction of the original language. In this way, we obtain that the family of languages of $\textit{1TAPE}[T'(n)]$ is contained into the family of languages $\textit{1TAPE}[T'(\frac{n}{G(n)})]$ for some function $G(n) > 1$ under the assumption that $\textit{1TAPE}[T'(n)]$ is not closed under deterministic two-way logarithmic space reduction. As result, we obtain that $\textit{1TAPE}[T'(n)] = \textit{1TAPE}[T'(\frac{n}{G(n)})]$ since we previously know that $\textit{1TAPE}[T'(\frac{n}{G(n)})] \subseteq \textit{1TAPE}[T'(n)]$ and we show that $\textit{1TAPE}[T'(n)] \subseteq \textit{1TAPE}[T'(\frac{n}{G(n)})]$ under our supposition. Since $\textit{1TAPE}[T'(n)]$ is not equal to $\textit{1TAPE}[T'(\frac{n}{G(n)})]$ for some function $G(n) > 1$, then we obtain that necessarily $\textit{1TAPE}[T'(n)]$ should be closed under deterministic two-way logarithmic space reduction by the reductio ad absurdum logic rule \cite{FE16}. In general, we can assume the same result for every sparse function $T(n)$.
\end{proof}

\begin{theorem}
\label{partially}
$1L \neq 1NL$ under deterministic two-way logarithmic space reduction.
\end{theorem}

\begin{proof}
Hartmanis and Mahaney have shown that $1NL \varsubsetneq \textit{1TAPE}[T(n)]$ when
\[\lim_{n\to\infty} \frac{T(n)}{n} = 0\]
in their paper \cite{HM81}. Consequently, this is a direct result of Theorem \ref{closed}.
\end{proof}

\begin{theorem}
\label{negation}
$L \neq NL$.
\end{theorem}

\begin{proof}
We obtain that $2L \subseteq L$ and $2NL \subseteq NL$ by the definition of $L$ and $NL$ under the $\textit{L--reduction}$ and $\textit{NL--reduction}$, respectively. Certainly, since the output string will be in $1L$ or $1NL$, then we do not need to reset the computation of the $\textit{L--reduction}$ or $\textit{NL--reduction}$ in order to be decided by a deterministic or nondeterministic logarithmic space Turing machine under logarithmic space composition, respectively.

On the one hand, every language in $L_{1} \in L$ which is decided by a deterministic logarithmic space Turing machine $M$ could be $\textit{L--reduced}$ to a language in $1L$. The reason is simple, because the Turing machine $M$ could output the sequence of symbols that is read consecutively in the input tape during the whole computation in case of acceptance. Indeed, for every read symbol in the input tape in $M$, then this is written to the output tape in a sequential way. In this way, the output string could be accepted by a deterministic one-way logarithmic space Turing machine, that would be the same Turing machine $M$ where this one will always read on the input tape from left-to-right. Certainly, when $M$ tries to move the head of the input tape to the left into the output string, then this will move contiguously to the right. Consequently, $M$ in case of acceptance will output the strings that consist in a language in $1L$. Hence, we obtain that $L \subseteq 2L$. Since we already know that $2L \subseteq L$, then $L = 2L$.

On the other hand, every language in $L_{2} \in NL$ which is decided by a nondeterministic logarithmic space Turing machine $N$ could be $\textit{NL--reduced}$ to a language in $1NL$. The reason is simple, because the Turing machine $N$ could output the sequence of symbols that is read consecutively in the input tape during the whole computation in case of acceptance. Indeed, for every read symbol in the input tape in $N$, then this is written to the output tape in a sequential way. In this way, the output string could be accepted by a nondeterministic one-way logarithmic space Turing machine, that would be the same Turing machine $N$ where this one will always read on the input tape from left-to-right. Certainly, when $N$ tries to move the head of the input tape to the left into the output string, then this will move contiguously to the right. Consequently, $N$ in case of acceptance will output the strings that consist in a language in $1NL$. Hence, we obtain that $NL \subseteq 2NL$. Since we already know that $2NL \subseteq NL$, then $NL = 2NL$.

In this way, if $L = NL$ then $2L = 2NL$. However, we know that $2L \neq 2NL$ because of $1L \neq 1NL$ under deterministic two-way logarithmic space reduction according to the Theorem \ref{partially}. Indeed, in case of $2L = 2NL$, then every language in $1NL$ is deterministic two-way logarithmic space reduced to a language in $1L$ and viceversa. Consequently, we prove the complexity class $L$ is not equal to $NL$.
\end{proof}

\begin{theorem}
\label{argument}
If the Hypothesis \ref{hypothesis} is true, then $P = NP$.
\end{theorem}

\begin{proof}
This is a direct consequence of Theorems \ref{implication} and \ref{negation}.
\end{proof}

\subsection{Codes}

This work is implemented into a Project programmed in Scala \cite{FV19}. We need to install JDK 8 in order to test the Scala Project \cite{OD16}. In addition, we need to install SBT to run the unit test (we could run the unit test with the $\textbf{sbt test}$ command) \cite{OD16}.


\section{Results}

We show a previous known $\textit{NP--complete}$ problem:

\begin{definition}
$\textbf{NAE 3SAT}$

INSTANCE: A Boolean formula $\phi$ in $3CNF$.

QUESTION: Is there a truth assignment for $\phi$ such that each clause has at least one true literal and at least one false literal?

REMARKS: $\textit{NAE 3SAT} \in \textit{NP--complete}$ \cite{GJ79}.
\end{definition}

We define a new problem:

\begin{definition}
$\textbf{MINIMUM EXCLUSIVE-OR 2-SATISFIABILITY}$

INSTANCE: A positive integer $K$ and a Boolean formula $\phi$ that is an instance of $\textit{XOR 2SAT}$.

QUESTION: Is there a truth assignment in $\phi$ such that at most $K$ clauses are unsatisfiable?

REMARKS: We denote this problem as $MIN\oplus2SAT$.
\end{definition}


\begin{theorem}
\label{completeness}
$MIN\oplus2SAT \in \textit{NP--complete}$.
\end{theorem}

\begin{proof}
It is trivial to see $MIN\oplus2SAT \in NP$ \cite{Pap03}. Given a Boolean formula $\phi$ in $3CNF$ with $n$ variables and $m$ clauses, we create three new variables $a_{c_{i}}$, $b_{c_{i}}$ and $d_{c_{i}}$ for each clause $c_{i} = (x \vee y \vee z)$ in $\phi$, where $x$, $y$ and $z$ are literals, in the following formula:
\[P_{i} = (a_{c_{i}} \oplus b_{c_{i}}) \wedge (b_{c_{i}} \oplus d_{c_{i}}) \wedge (a_{c_{i}} \oplus d_{c_{i}}) \wedge (x \oplus a_{c_{i}}) \wedge (y \oplus b_{c_{i}}) \wedge (z \oplus d_{c_{i}}).\]
We can see $P_{i}$ has at most one unsatisfiable clause for some truth assignment if and only if at least one member of $\{x,y,z\}$ is true and at least one member of $\{x,y,z\}$ is false for the same truth assignment. Hence, we can create the Boolean formula $\psi$ as the conjunction of the $P_{i}$ formulas for every clause $c_{i}$ in $\phi$, such that $\psi = P_{1} \wedge \ldots \wedge P_{m}$. Finally, we obtain that
\[\phi \in \textit{NAE 3SAT} \textit{ if and only if } (\psi, m) \in MIN\oplus2SAT.\]
Consequently, we prove $\textit{NAE 3SAT} \leq_{p} MIN\oplus2SAT$ where we already know the language $\textit{NAE 3SAT} \in \textit{NP--complete}$ \cite{GJ79}. To sum up, we show $MIN\oplus2SAT \in \textit{NP--hard}$ and $MIN\oplus2SAT \in NP$ and thus, $MIN\oplus2SAT \in \textit{NP--complete}$.
\end{proof}

\begin{theorem}
\label{proof}
There is a deterministic Turing machine $M$, where:
\[MIN\oplus2SAT = \{w: M(w, u) = y \textit{ for some string } u \textit{ such that } y \in \textit{XOR 2SAT}\}\]
when $M$ runs in logarithmic space in the length of $w$, $u$ is placed on the special read-once tape of $M$, and $u$ is polynomially bounded by $w$.
\end{theorem}

\begin{proof}
Given a valid instance $(\psi, K)$ for $MIN\oplus2SAT$ when $\psi$ has $m$ clauses, we can create a certificate array $A$ which contains $K$ different natural numbers in ascending order which represents the indexes of the clauses in $\psi$ that we are going to remove from the instance. We read at once the elements of the array $A$ and we reject whether this is not a valid certificate: That is when the numbers are not sorted in ascending order, or the array $A$ does not contain exactly $K$ elements, or the array $A$ contains a number that is not between $1$ and $m$. While we read the elements of the array $A$, we remove the clauses from the instance $(\psi, K)$ for $MIN\oplus2SAT$ just creating another instance $\phi$ for $\textit{XOR 2SAT}$ where the Boolean formula $\phi$ does not contain the $K$ different indexed clauses $\psi$ represented by the numbers in $A$. Therefore, we obtain the array $A$ should be valid according to the Theorem \ref{proof} when:
\[(\psi, K) \in MIN\oplus2SAT \textit{ if and only if } \phi \in \textit{XOR 2SAT}.\]
Furthermore, we can make this verification in logarithmic space such that the array $A$ is placed on the special read-once tape, because we read at once the elements in the array $A$ and we assume the clauses in the input $\psi$ are indexed from left to right. Hence, we only need to iterate from the elements of the array $A$ to verify whether the array is a valid certificate and also remove the $K$ different clauses from the Boolean formula $\psi$ when we write the final clauses to the output. This logarithmic space verification will be the Algorithm \ref{algorithm}. We assume whether a value does not exist in the array $A$ into the cell of some position $i$ when $A[i] = undefined$. In addition, we reject immediately when the following comparisons
\[A[i] \leq max \vee A[i] < 1 \vee A[i] > m\]
hold at least into one single binary digit. Note, in the loop $j$ from $min$ to $max - 1$, we do not output any clause when $max - 1 < min$.

\begin{algorithm}
\caption{Logarithmic space verifier}\label{algorithm}
\begin{algorithmic}[1]
\Comment{A valid instance for $MIN\oplus2SAT$ with its certificate}
\Procedure{$\textit{VERIFIER}$}{$(\psi, K), A$}
\Comment{Initialize minimum and maximum values}
\State $min \gets 1$
\State $max \gets 0$
\Comment{Iterate for the elements of the certificate array $A$}
\For{$i$}{$1$}{$K + 1$}
\If{$i = K+1$}
\Comment{There exists a $K+1$ element in the array}
\If{$A[i] \neq undefined$}
\Comment{Reject the certificate}
\State \textbf{return} $0$
\EndIf
\Comment{$m$ is the number of clauses in $\psi$}
\State $max \gets m + 1$
\ElsIf{$A[i] = undefined \vee A[i] \leq max \vee A[i] < 1 \vee A[i] > m$}
\Comment{Reject the certificate}
\State \textbf{return} $0$
\Else
\State $max \gets A[i]$
\EndIf
\Comment{Iterate for the clauses of the Boolean formula $\psi$}
\For{$j$}{$min$}{$max - 1$}
\Comment{Output the indexed $j$ clause in $\psi$}
\State \textbf{output} $``\wedge c_{j}"$
\EndFor
\State $min \gets max + 1$
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
\end{proof}

\begin{theorem}
\label{result}
The Hypothesis \ref{hypothesis} is true.
\end{theorem}

\begin{proof}
This is a consequence of Theorems \ref{completeness} and \ref{proof}.
\end{proof}

\begin{theorem}
$P = NP$.
\end{theorem}

\begin{proof}
This is a direct consequence of Theorems \ref{argument} and \ref{result}.
\end{proof}


\section{Conclusions}

No one has been able to find a polynomial time algorithm for any of more than $300$ important known $\textit{NP--complete}$ problems \cite{GJ79}. A proof of $P = NP$ will have stunning practical consequences, because it leads to efficient methods for solving some of the important problems in $NP$ \cite{CS00}. The consequences, both positive and negative, arise since various $\textit{NP--complete}$ problems are fundamental in many fields \cite{CS00}. All the following consequences are assuming that we have a practical solution for the $\textit{NP--complete}$ problems where such existence was proven with our result:

Cryptography, for example, relies on certain problems being difficult. A constructive and efficient solution to an $\textit{NP--complete}$ problem such as $3SAT$ will break most existing cryptosystems including: Public-key cryptography \cite{HW97}, symmetric ciphers \cite{MM00} and one-way functions used in cryptographic hashing \cite{DKV07}. These would need to be modified or replaced by information-theoretically secure solutions not inherently based on $\textit{P--NP}$ equivalence.

There are enormous positive consequences that will follow from rendering tractable many currently mathematically intractable problems. For instance, many problems in operations research are $\textit{NP--complete}$, such as some types of integer programming and the traveling salesman problem \cite{GJ79}. Efficient solutions to these problems have enormous implications for logistics \cite{CS00}. Many other important problems, such as some problems in protein structure prediction, are also $\textit{NP--complete}$, so this will spur considerable advances in biology \cite{BL98}.

Since all the $\textit{NP--complete}$ optimization problems become easy, everything will be much more efficient \cite{LF09}. Transportation of all forms will be scheduled optimally to move people and goods around quicker and cheaper \cite{LF09}. Manufacturers can improve their production to increase speed and create less waste \cite{LF09}.

Learning becomes easy by using the principle of Occam's razor: We simply find the smallest program consistent with the data \cite{LF09}. Near perfect vision recognition, language comprehension and translation and all other learning tasks become trivial \cite{LF09}. We will also have much better predictions of weather and earthquakes and other natural phenomenon \cite{LF09}.

The economy would become vastly more efficient. There would be disruption, including maybe displacing programmers \cite{IMP95}. The practice of programming itself would be more about gathering training data and less about writing code \cite{IMP95}. Google would have the resources to excel in such a world \cite{IMP95}.

But such changes may pale in significance compared to the revolution an efficient method for solving $\textit{NP--complete}$ problems will cause in mathematics itself. Research mathematicians spend their careers trying to prove theorems, and some proofs have taken decades or even centuries to find after problems have been stated. For instance, Fermat's Last Theorem took over three centuries to prove. A method that is guaranteed to find proofs to theorems, should one exist of a $``$reasonable$"$ size, would essentially end this struggle \cite{CS00}.


\bibliography{manuscript}


\end{document}
